<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Analisi Arciere - Polisportiva Gonone Dorgali</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Analisi postura arcieri con AI - Polisportiva Gonone Dorgali">
    <meta name="theme-color" content="#2563eb">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Analisi Arciere">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="logo-pol.png">
    
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
    <!-- BodyPix -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix"></script>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Oswald:wght@300;400;500;600;700&family=Source+Sans+Pro:wght@300;400;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg-primary: #0a0a0b;
            --bg-secondary: #141416;
            --bg-tertiary: #1c1c1f;
            --accent-olympic: #2563eb;
            --accent-compound: #dc2626;
            --accent-barebow: #16a34a;
            --accent-current: var(--accent-olympic);
            --text-primary: #ffffff;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;
            --border-color: #27272a;
            --success: #22c55e;
            --warning: #eab308;
            --danger: #ef4444;
        }
        
        body {
            font-family: 'Source Sans Pro', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* Header - Versione Compatta */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
            height: 50px;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .logo {
            font-family: 'Oswald', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .header-logo {
            width: 32px;
            height: 32px;
            object-fit: contain;
            border-radius: 6px;
        }
        
        /* Header Hamburger Menu */
        .header-hamburger {
            width: 36px;
            height: 36px;
            border: none;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 8px;
        }
        
        .header-hamburger span {
            display: block;
            width: 18px;
            height: 2px;
            background: var(--text-primary);
            border-radius: 1px;
            transition: all 0.3s ease;
        }
        
        .header-hamburger.open span:nth-child(1) {
            transform: rotate(45deg) translate(4px, 4px);
        }
        
        .header-hamburger.open span:nth-child(2) {
            opacity: 0;
        }
        
        .header-hamburger.open span:nth-child(3) {
            transform: rotate(-45deg) translate(4px, -4px);
        }
        
        /* Header Dropdown Menu */
        .header-dropdown {
            display: none;
            position: fixed;
            top: 50px;
            left: 0.5rem;
            right: 0.5rem;
            max-width: 320px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 0.75rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            z-index: 200;
            max-height: calc(100vh - 60px);
            overflow-y: auto;
        }
        
        .header-dropdown.open {
            display: block;
        }
        
        .header-menu-section {
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .header-menu-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .header-menu-title {
            font-family: 'Oswald', sans-serif;
            font-size: 0.7rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 0.4rem;
        }
        
        .header-menu-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
        }
        
        .header-menu-btn {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: 'Oswald', sans-serif;
            font-size: 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .header-menu-btn:hover {
            background: var(--bg-primary);
        }
        
        .header-menu-btn.active {
            background: var(--accent-current);
            border-color: var(--accent-current);
            color: white;
        }
        
        .header-menu-btn.icon-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .header-menu-btn svg {
            width: 16px;
            height: 16px;
        }
        
        /* Athlete display in header */
        .header-athlete {
            font-family: 'Oswald', sans-serif;
            font-size: 0.85rem;
            color: var(--accent-current);
        }
        
        /* Bow Type Selector */
        .bow-selector {
            display: flex;
            gap: 0.5rem;
            background: var(--bg-tertiary);
            padding: 4px;
            border-radius: 10px;
        }
        
        .bow-btn {
            padding: 0.5rem 1rem;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-family: 'Oswald', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            letter-spacing: 1px;
            text-transform: uppercase;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .bow-btn:hover {
            color: var(--text-primary);
        }
        
        .bow-btn.active {
            background: var(--accent-current);
            color: white;
        }
        
        .bow-btn[data-bow="olympic"].active { background: var(--accent-olympic); }
        .bow-btn[data-bow="compound"].active { background: var(--accent-compound); }
        .bow-btn[data-bow="barebow"].active { background: var(--accent-barebow); }
        
        /* Settings Gear Button */
        .settings-gear-btn {
            width: 36px;
            height: 36px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            margin-left: 0.5rem;
        }
        
        .settings-gear-btn:hover {
            color: var(--text-primary);
            background: var(--bg-secondary);
        }
        
        .settings-gear-btn svg {
            width: 20px;
            height: 20px;
        }
        
        /* Athlete Button */
        .athlete-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Oswald', sans-serif;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }
        
        .athlete-btn:hover {
            border-color: var(--accent-current);
        }
        
        .athlete-btn svg {
            width: 20px;
            height: 20px;
        }
        
        /* Help Button */
        .help-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .help-btn:hover {
            color: var(--text-primary);
            border-color: var(--accent-current);
        }
        
        .help-btn svg {
            width: 20px;
            height: 20px;
        }
        
        /* Manual Content */
        .manual-content {
            line-height: 1.6;
        }
        
        .manual-content h2 {
            font-family: 'Oswald', sans-serif;
            color: var(--accent-current);
            margin-bottom: 0.5rem;
        }
        
        .manual-content h3 {
            font-family: 'Oswald', sans-serif;
            font-size: 1.1rem;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }
        
        .manual-content p {
            margin-bottom: 0.75rem;
        }
        
        .manual-content ul, .manual-content ol {
            margin-left: 1.25rem;
            margin-bottom: 1rem;
        }
        
        .manual-content li {
            margin-bottom: 0.4rem;
        }
        
        /* Versions List */
        .versions-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .version-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            text-decoration: none;
            color: var(--text-primary);
            transition: all 0.2s ease;
        }
        
        .version-item:hover {
            background: var(--bg-primary);
            border-color: var(--accent-current);
        }
        
        .version-item.current {
            border-color: var(--accent-current);
            background: rgba(37, 99, 235, 0.1);
        }
        
        .version-badge {
            font-family: 'Oswald', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            padding: 0.3rem 0.6rem;
            background: var(--bg-secondary);
            border-radius: 6px;
            min-width: 45px;
            text-align: center;
        }
        
        .version-item.current .version-badge {
            background: var(--accent-current);
            color: white;
        }
        
        .version-info {
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
        }
        
        .version-name {
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        .version-desc {
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        /* Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        
        .modal-overlay.open {
            display: flex;
        }
        
        .modal {
            background: var(--bg-secondary);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .modal-title {
            font-family: 'Oswald', sans-serif;
            font-size: 1.2rem;
            font-weight: 500;
            letter-spacing: 1px;
        }
        
        .modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .modal-body {
            padding: 1.5rem;
        }
        
        .modal-footer {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-color);
        }
        
        /* Archivio Styles */
        .archivio-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }
        
        .archivio-tab {
            flex: 1;
            padding: 0.85rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-family: 'Oswald', sans-serif;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .archivio-tab:hover {
            background: var(--bg-tertiary);
        }
        
        .archivio-tab.active {
            color: var(--accent-current);
            border-bottom: 2px solid var(--accent-current);
        }
        
        .archivio-content {
            padding: 1rem;
            max-height: 50vh;
            overflow-y: auto;
        }
        
        .archivio-toolbar {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .archivio-input {
            flex: 1;
            padding: 0.6rem 0.8rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.9rem;
        }
        
        .archivio-btn-add {
            padding: 0.6rem 1rem;
            background: var(--accent-current);
            border: none;
            border-radius: 8px;
            color: white;
            font-family: 'Oswald', sans-serif;
            cursor: pointer;
        }
        
        .archivio-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .archivio-empty {
            text-align: center;
            color: var(--text-muted);
            padding: 2rem;
            font-size: 0.9rem;
        }
        
        .archivio-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .archivio-item:hover {
            background: var(--bg-primary);
        }
        
        .archivio-item-info {
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }
        
        .archivio-item-name {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .archivio-item-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .archivio-item-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .archivio-item-btn {
            padding: 0.4rem 0.6rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.75rem;
            cursor: pointer;
        }
        
        .archivio-item-btn:hover {
            background: var(--accent-current);
            border-color: var(--accent-current);
        }
        
        .archivio-item-btn.danger:hover {
            background: var(--danger);
            border-color: var(--danger);
        }
        
        .archivio-header-back {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .archivio-btn-back {
            padding: 0.4rem 0.8rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.85rem;
            cursor: pointer;
        }
        
        .archivio-actions {
            padding: 1rem;
            border-top: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }
        
        .archivio-selected-info {
            margin-bottom: 0.75rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .archivio-action-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .archivio-btn {
            padding: 0.6rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Oswald', sans-serif;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .archivio-btn:hover {
            background: var(--accent-current);
            border-color: var(--accent-current);
            color: white;
        }
        
        .archivio-btn.primary {
            background: var(--accent-current);
            border-color: var(--accent-current);
            color: white;
        }
        
        .archivio-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            background: var(--success);
            color: white;
            border-radius: 4px;
            font-size: 0.7rem;
            margin-left: 0.5rem;
        }
        
        .archivio-badge.pending {
            background: var(--warning);
        }

        /* Settings Form */
        .settings-section {
            margin-bottom: 1.5rem;
        }
        
        .settings-section:last-child {
            margin-bottom: 0;
        }
        
        .settings-section-title {
            font-family: 'Oswald', sans-serif;
            font-size: 0.9rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0;
        }
        
        .settings-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }
        
        .settings-label .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .settings-inputs {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .settings-input {
            width: 60px;
            padding: 0.4rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'Source Sans Pro', sans-serif;
            font-size: 0.85rem;
            text-align: center;
        }
        
        .settings-input:focus {
            outline: none;
            border-color: var(--accent-current);
        }
        
        .settings-input-label {
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        
        /* Form inputs */
        .form-group {
            margin-bottom: 1rem;
        }
        
        .form-label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.4rem;
        }
        
        .form-input {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Source Sans Pro', sans-serif;
            font-size: 0.95rem;
        }
        
        .form-input:focus {
            outline: none;
            border-color: var(--accent-current);
        }
        
        .form-select {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Source Sans Pro', sans-serif;
            font-size: 0.95rem;
            cursor: pointer;
        }
        
        /* Buttons */
        .btn {
            padding: 0.6rem 1.25rem;
            border: none;
            border-radius: 8px;
            font-family: 'Oswald', sans-serif;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-primary {
            background: var(--accent-current);
            color: white;
        }
        
        .btn-primary:hover {
            filter: brightness(1.1);
        }
        
        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .btn-secondary:hover {
            background: var(--bg-primary);
        }
        
        .btn-danger {
            background: var(--danger);
            color: white;
        }
        
        /* Athletes List */
        .athletes-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 1rem;
        }
        
        .athlete-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .athlete-item:hover {
            background: var(--bg-primary);
        }
        
        .athlete-item.selected {
            border: 2px solid var(--accent-current);
        }
        
        .athlete-info {
            display: flex;
            flex-direction: column;
        }
        
        .athlete-name {
            font-weight: 500;
        }
        
        .athlete-bow {
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .athlete-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .athlete-action-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .athlete-action-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .athlete-action-btn.delete:hover {
            color: var(--danger);
        }
        
        /* PIN Input */
        .pin-container {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            margin: 1.5rem 0;
        }
        
        .pin-input {
            width: 50px;
            height: 60px;
            text-align: center;
            font-size: 1.5rem;
            font-family: 'Oswald', sans-serif;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-primary);
        }
        
        .pin-input:focus {
            outline: none;
            border-color: var(--accent-current);
        }
        
        .pin-error {
            color: var(--danger);
            text-align: center;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }
        
        /* Main Container */
        .main-container {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 1.5rem;
            padding: 1.5rem;
            max-width: 1600px;
            margin: 0 auto;
        }
        
        @media (max-width: 1024px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
        
        /* Video Section */
        .video-section {
            background: var(--bg-secondary);
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }
        
        .video-container {
            position: relative;
            background: #000;
        }
        
        #videoElement {
            display: block;
            width: 100%;
        }
        
        #playbackVideo {
            display: none;
            width: 100%;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* Mode Indicator */
        .mode-indicator {
            position: absolute;
            top: 1rem;
            left: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-family: 'Oswald', sans-serif;
            font-size: 0.8rem;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        
        .mode-dot {
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .mode-indicator.recording .mode-dot {
            background: var(--danger);
        }
        
        .mode-indicator.playback .mode-dot {
            background: var(--accent-olympic);
            animation: none;
        }
        
        /* FPS Counter */
        .fps-counter {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(10px);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-family: 'Oswald', sans-serif;
            font-size: 0.8rem;
            letter-spacing: 1px;
        }
        
        /* Angles Overlay */
        .angles-overlay {
            position: absolute;
            top: 4rem;
            left: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
            z-index: 10;
        }
        
        .angle-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            font-family: 'Oswald', sans-serif;
            font-size: 0.75rem;
            border-left: 3px solid var(--angle-color, #fff);
        }
        
        .angle-label {
            color: var(--text-secondary);
            min-width: 90px;
        }
        
        .angle-value {
            color: var(--angle-color, #fff);
            font-weight: 600;
            min-width: 40px;
            text-align: right;
        }
        
        .angle-item.good { --angle-color: var(--success); }
        .angle-item.warning { --angle-color: var(--warning); }
        .angle-item.bad { --angle-color: var(--danger); }
        
        /* Controls Bar */
        .controls-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.5rem;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .control-btn {
            width: 48px;
            height: 48px;
            border: none;
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            border: 1px solid var(--border-color);
        }
        
        .control-btn:hover {
            background: var(--bg-primary);
            transform: scale(1.05);
        }
        
        .control-btn.primary {
            width: 56px;
            height: 56px;
            background: var(--accent-current);
            border: none;
        }
        
        .control-btn.primary:hover {
            filter: brightness(1.1);
        }
        
        .control-btn.recording {
            background: var(--danger);
            animation: recording-pulse 1s infinite;
        }
        
        @keyframes recording-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
            50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        }
        
        .control-btn svg {
            width: 24px;
            height: 24px;
        }
        
        /* Playback Controls - Layout chiaro */
        .playback-controls {
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
        }
        
        .playback-controls.active {
            display: flex;
        }
        
        .timeline {
            width: 100%;
            height: 8px;
            background: var(--bg-primary);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
        }
        
        .timeline-progress {
            height: 100%;
            background: var(--accent-current);
            border-radius: 4px;
            width: 0%;
        }
        
        .timeline-handle {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: grab;
        }
        
        /* Due righe di controlli */
        .playback-row-1, .playback-row-2 {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .playback-buttons .control-btn {
            width: 44px;
            height: 44px;
            flex-shrink: 0;
            border-radius: 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
        }
        
        .playback-buttons .control-btn.primary {
            width: 52px;
            height: 52px;
            background: var(--accent-current);
            border: none;
        }
        
        .playback-buttons .control-btn svg {
            width: 22px;
            height: 22px;
        }
        
        .frame-counter {
            font-family: 'Oswald', sans-serif;
            font-size: 0.85rem;
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 0.4rem 0.75rem;
            border-radius: 6px;
            min-width: 70px;
            text-align: center;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .speed-btn {
            padding: 0.4rem 0.6rem;
            font-size: 0.75rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-family: 'Oswald', sans-serif;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .speed-btn:hover, .speed-btn.active {
            background: var(--accent-current);
            color: white;
            border-color: var(--accent-current);
        }
        
        /* Controlli Griglia Playback */
        .playback-grid-controls {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            margin-left: 0.5rem;
        }
        
        .grid-density-btn {
            padding: 0.3rem 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-family: 'Oswald', sans-serif;
            font-size: 0.7rem;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .grid-density-btn:hover,
        .grid-density-btn.active {
            background: var(--accent-current);
            color: white;
            border-color: var(--accent-current);
        }
        
        /* Grid Menu con Dropdown */
        .grid-menu {
            position: relative;
            display: inline-block;
        }
        
        .grid-dropdown {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            min-width: 80px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .grid-dropdown.show {
            display: block;
        }
        
        .grid-option {
            display: block;
            width: 100%;
            padding: 0.4rem 0.6rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.8rem;
            font-family: 'Oswald', sans-serif;
            cursor: pointer;
            margin-bottom: 0.25rem;
            transition: all 0.2s;
            text-align: center;
        }
        
        .grid-option:hover,
        .grid-option.active {
            background: var(--accent-current);
            border-color: var(--accent-current);
            color: white;
        }
        
        .grid-option:last-child {
            margin-bottom: 0;
        }
        
        .speed-btn {
            padding: 0.4rem 0.8rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-family: 'Oswald', sans-serif;
            font-size: 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .speed-btn:hover, .speed-btn.active {
            background: var(--accent-current);
            color: white;
            border-color: var(--accent-current);
        }
        
        /* Analyze Menu con Dropdown */
        .analyze-menu {
            position: relative;
            display: inline-block;
        }
        
        .analyze-dropdown {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            min-width: 120px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .analyze-menu:hover .analyze-dropdown,
        .analyze-dropdown.show {
            display: block;
        }
        
        .analyze-dropdown-title {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.5rem;
            text-align: center;
        }
        
        .analyze-option {
            display: block;
            width: 100%;
            padding: 0.5rem 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.85rem;
            cursor: pointer;
            margin-bottom: 0.25rem;
            transition: all 0.2s;
        }
        
        .analyze-option:hover {
            background: var(--accent-current);
            border-color: var(--accent-current);
        }
        
        .analyze-option:last-child {
            margin-bottom: 0;
        }
        
        /* Analyze Button */
        .analyze-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 0.5rem 1rem;
            min-width: 60px;
        }
        
        .analyze-btn svg {
            width: 20px;
            height: 20px;
        }
        
        .analyze-text {
            font-family: 'Oswald', sans-serif;
            font-size: 0.65rem;
            letter-spacing: 1px;
        }
        
        .analyze-btn.analyzing {
            background: var(--warning);
            border-color: var(--warning);
            color: black;
        }
        
        .analyze-btn.done {
            background: var(--success);
            border-color: var(--success);
            color: white;
        }
        
        .frame-counter {
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            color: var(--text-secondary);
            min-width: 120px;
            text-align: center;
        }
        
        /* Sidebar */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .panel {
            background: var(--bg-secondary);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }
        
        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .panel-title {
            font-family: 'Oswald', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-secondary);
        }
        
        .panel-content {
            padding: 1rem 1.25rem;
        }
        
        /* Alignment Indicators */
        .alignment-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .alignment-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-radius: 10px;
            border-left: 3px solid var(--text-muted);
            transition: all 0.3s ease;
        }
        
        .alignment-item.good {
            border-left-color: var(--success);
        }
        
        .alignment-item.warning {
            border-left-color: var(--warning);
        }
        
        .alignment-item.bad {
            border-left-color: var(--danger);
        }
        
        .alignment-name {
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        
        .alignment-value {
            font-family: 'Oswald', sans-serif;
            font-size: 1.1rem;
            font-weight: 500;
        }
        
        .alignment-item.good .alignment-value { color: var(--success); }
        .alignment-item.warning .alignment-value { color: var(--warning); }
        .alignment-item.bad .alignment-value { color: var(--danger); }
        
        /* Grid Density Selector */
        .grid-density-select {
            padding: 0.4rem 0.6rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Oswald', sans-serif;
            font-size: 0.75rem;
            cursor: pointer;
        }
        
        .grid-density-select:focus {
            outline: none;
            border-color: var(--accent-current);
        }
        
        /* Athlete Selector */
        .athlete-input {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-primary);
            font-family: 'Source Sans Pro', sans-serif;
            font-size: 0.95rem;
        }
        
        .athlete-input:focus {
            outline: none;
            border-color: var(--accent-current);
        }
        
        /* Server Mode Selector */
        .server-mode-selector {
            display: flex;
            gap: 0.5rem;
        }
        
        .server-mode-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            padding: 0.75rem 0.5rem;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .server-mode-btn:hover {
            border-color: var(--text-muted);
        }
        
        .server-mode-btn.active {
            border-color: var(--accent-current);
            background: rgba(37, 99, 235, 0.1);
            color: var(--text-primary);
        }
        
        .server-mode-btn .mode-icon {
            font-size: 1.25rem;
        }
        
        .server-mode-btn .mode-name {
            font-family: 'Oswald', sans-serif;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .server-input {
            width: 100%;
            padding: 0.6rem 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Source Sans Pro', sans-serif;
            font-size: 0.9rem;
        }
        
        .server-input:focus {
            outline: none;
            border-color: var(--accent-current);
        }
        
        .server-test-btn {
            padding: 0.6rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Oswald', sans-serif;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .server-test-btn:hover {
            background: var(--accent-current);
            border-color: var(--accent-current);
        }
        
        .server-status {
            padding: 0.5rem;
            border-radius: 6px;
        }
        
        .server-status.success {
            background: rgba(34, 197, 94, 0.1);
            color: var(--success);
        }
        
        .server-status.error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--danger);
        }
        
        .server-status.loading {
            color: var(--text-muted);
        }
        
        .server-open-btn {
            width: 100%;
            padding: 0.85rem 1rem;
            background: linear-gradient(135deg, var(--accent-current), #1d4ed8);
            border: none;
            border-radius: 10px;
            color: white;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .server-open-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
        }
        
        .server-open-btn:active {
            transform: translateY(0);
        }

        /* Recordings List */
        .recordings-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .recording-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .recording-item:hover {
            background: var(--bg-primary);
        }
        
        .recording-info {
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
            flex: 1;
        }
        
        .recording-name {
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        
        .recording-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        
        .recording-comment {
            font-size: 0.75rem;
            color: var(--text-secondary);
            background: transparent;
            border: none;
            border-bottom: 1px dashed var(--border-color);
            padding: 0.2rem 0;
            margin-top: 0.2rem;
            width: 100%;
            font-style: italic;
        }
        
        .recording-comment:focus {
            outline: none;
            border-bottom-color: var(--accent-current);
        }
        
        .recording-comment::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }
        
        .recording-delete {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .recording-delete:hover {
            background: var(--danger);
            color: white;
        }
        
        .recording-actions {
            display: flex;
            gap: 0.25rem;
        }
        
        .recording-download {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .recording-download:hover {
            background: var(--accent-current);
            color: white;
        }
        
        /* Elaborazioni (sottoprodotti) */
        .recording-group {
            margin-bottom: 0.5rem;
        }
        
        .elaborations-list {
            margin-left: 1rem;
            padding-left: 0.75rem;
            border-left: 2px solid var(--border-color);
            margin-top: 0.25rem;
        }
        
        .elaboration-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.6rem;
            background: var(--bg-primary);
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 0.25rem;
            font-size: 0.8rem;
            transition: all 0.2s;
        }
        
        .elaboration-item:hover {
            background: var(--bg-tertiary);
        }
        
        .elaboration-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 22px;
            height: 22px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.75rem;
            color: white;
        }
        
        .elaboration-badge.model-holistic {
            background: #9b59b6; /* viola */
        }
        
        .elaboration-badge.model-lightning {
            background: #f39c12; /* arancione */
        }
        
        .elaboration-badge.model-bodypix {
            background: #3498db; /* blu */
        }
        
        .elaboration-icons {
            color: var(--text-muted);
            font-size: 0.9rem;
            letter-spacing: 2px;
        }
        
        .elaboration-time {
            color: var(--text-muted);
            font-size: 0.7rem;
            flex: 1;
        }
        
        .elaboration-download {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            color: var(--text-muted);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            margin-left: auto;
        }
        
        .elaboration-download:hover {
            background: var(--accent-current);
            color: white;
        }
        
        /* Tips Panel */
        .tips-content {
            font-size: 0.9rem;
            line-height: 1.6;
            color: var(--text-secondary);
        }
        
        .tip-item {
            display: flex;
            gap: 0.75rem;
            padding: 0.75rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .tip-item:last-child {
            border-bottom: none;
        }
        
        .tip-icon {
            width: 24px;
            height: 24px;
            flex-shrink: 0;
            color: var(--accent-current);
        }
        
        /* Camera Select */
        .camera-select {
            width: 100%;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-primary);
            font-family: 'Source Sans Pro', sans-serif;
            font-size: 0.95rem;
            cursor: pointer;
        }
        
        .camera-select:focus {
            outline: none;
            border-color: var(--accent-current);
        }
        
        /* Stance Selector */
        .stance-selector {
            display: flex;
            gap: 0.5rem;
        }
        
        .stance-btn {
            flex: 1;
            padding: 0.6rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-family: 'Oswald', sans-serif;
            font-size: 0.8rem;
            letter-spacing: 0.5px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .stance-btn:hover {
            border-color: var(--accent-current);
            color: var(--text-primary);
        }
        
        .stance-btn.active {
            background: var(--accent-current);
            border-color: var(--accent-current);
            color: white;
        }
        
        /* Model Selector */
        .model-selector {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }
        
        .model-btn {
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.15rem;
        }
        
        .model-btn:hover {
            border-color: var(--accent-current);
            color: var(--text-primary);
        }
        
        .model-btn.active {
            background: var(--accent-current);
            border-color: var(--accent-current);
            color: white;
        }
        
        .model-name {
            font-family: 'Oswald', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            letter-spacing: 0.5px;
        }
        
        .model-desc {
            font-size: 0.7rem;
            opacity: 0.8;
        }
        
        .model-btn.active .model-desc {
            opacity: 1;
        }
        
        /* Loading State */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1.5rem;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-current);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-family: 'Oswald', sans-serif;
            font-size: 1.1rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: var(--text-secondary);
        }
        
        .loading-logo {
            width: 220px;
            height: 220px;
            object-fit: contain;
            margin-bottom: 2rem;
        }
        
        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 2rem 1rem;
            color: var(--text-muted);
        }
        
        .empty-state svg {
            width: 48px;
            height: 48px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        /* Mobile Adjustments */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 1rem;
                padding: 1rem;
            }
            
            .main-container {
                padding: 1rem;
                gap: 1rem;
            }
            
            .controls-bar {
                flex-wrap: wrap;
                gap: 1rem;
                justify-content: center;
            }
            
            .video-container {
                aspect-ratio: 4/3;
            }
        }
        
        /* Fullscreen Styles */
        .video-section:fullscreen,
        .video-section:-webkit-full-screen {
            background: #000;
            width: 100vw !important;
            height: 100vh !important;
            display: flex;
            flex-direction: column;
        }
        
        .video-section:fullscreen .video-container,
        .video-section:-webkit-full-screen .video-container {
            flex: 1;
            width: 100% !important;
            height: 100% !important;
            max-height: none !important;
            aspect-ratio: unset !important;
        }
        
        .video-section:fullscreen canvas,
        .video-section:-webkit-full-screen canvas {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
        }
        
        .video-section:fullscreen .controls-bar,
        .video-section:-webkit-full-screen .controls-bar {
            display: none !important;
        }
        
        .video-section:fullscreen .playback-controls,
        .video-section:-webkit-full-screen .playback-controls {
            position: fixed !important;
            bottom: 0 !important;
            left: 0 !important;
            right: 0 !important;
            background: rgba(20, 20, 22, 0.95) !important;
            backdrop-filter: blur(10px) !important;
            z-index: 998 !important;
            padding: 0.75rem 1rem !important;
            border-top: 1px solid var(--border-color) !important;
        }
        
        .video-section:fullscreen .playback-controls .playback-buttons,
        .video-section:-webkit-full-screen .playback-controls .playback-buttons {
            flex-wrap: nowrap;
            justify-content: center;
        }
        
        .video-section:fullscreen .playback-controls .speed-control,
        .video-section:-webkit-full-screen .playback-controls .speed-control {
            display: flex;
        }
        
        /* Menu Hamburger (solo in fullscreen) */
        .hamburger-menu {
            display: none;
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.8);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .hamburger-menu span {
            display: block;
            width: 24px;
            height: 3px;
            background: white;
            border-radius: 2px;
            transition: all 0.3s ease;
        }
        
        .hamburger-menu.open span:nth-child(1) {
            transform: rotate(45deg) translate(6px, 6px);
        }
        
        .hamburger-menu.open span:nth-child(2) {
            opacity: 0;
        }
        
        .hamburger-menu.open span:nth-child(3) {
            transform: rotate(-45deg) translate(6px, -6px);
        }
        
        .video-section:fullscreen .hamburger-menu,
        .video-section:-webkit-full-screen .hamburger-menu {
            display: flex;
        }
        
        /* Menu a scomparsa fullscreen */
        .fullscreen-menu {
            display: none;
            position: fixed;
            top: 0;
            right: -320px;
            width: 300px;
            height: 100vh;
            background: rgba(20, 20, 22, 0.95);
            backdrop-filter: blur(20px);
            z-index: 999;
            padding: 80px 1.5rem 2rem;
            transition: right 0.3s ease;
            overflow-y: auto;
            border-left: 1px solid var(--border-color);
        }
        
        .fullscreen-menu.open {
            right: 0;
        }
        
        .video-section:fullscreen .fullscreen-menu,
        .video-section:-webkit-full-screen .fullscreen-menu {
            display: block;
        }
        
        .fs-menu-section {
            margin-bottom: 1.5rem;
        }
        
        .fs-menu-title {
            font-family: 'Oswald', sans-serif;
            font-size: 0.85rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.75rem;
        }
        
        .fs-menu-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .fs-menu-btn {
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Source Sans Pro', sans-serif;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            flex: 1;
            min-width: 80px;
            text-align: center;
        }
        
        .fs-menu-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-current);
        }
        
        .fs-menu-btn.active {
            background: var(--accent-current);
            border-color: var(--accent-current);
            color: white;
        }
        
        .fs-menu-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }
        
        .fs-close-btn {
            width: 100%;
            padding: 1rem;
            background: var(--danger);
            border: none;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            letter-spacing: 1px;
            margin-top: 1rem;
        }
        
        /* Overlay quando menu aperto */
        .menu-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 998;
        }
        
        .menu-overlay.open {
            display: block;
        }
        
        .video-section:fullscreen .menu-overlay,
        .video-section:-webkit-full-screen .menu-overlay {
            display: none;
        }
        
        .video-section:fullscreen .menu-overlay.open,
        .video-section:-webkit-full-screen .menu-overlay.open {
            display: block;
        }
    </style>
</head>
<body>
    <!-- PIN Modal -->
    <div class="modal-overlay" id="pinModal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title"> Inserisci PIN</span>
                <button class="modal-close" id="pinModalClose"></button>
            </div>
            <div class="modal-body">
                <p style="text-align: center; color: var(--text-secondary); margin-bottom: 1rem;">
                    Inserisci il PIN per accedere alla gestione atleti
                </p>
                <div class="pin-container">
                    <input type="password" class="pin-input" maxlength="1" data-pin="0">
                    <input type="password" class="pin-input" maxlength="1" data-pin="1">
                    <input type="password" class="pin-input" maxlength="1" data-pin="2">
                    <input type="password" class="pin-input" maxlength="1" data-pin="3">
                </div>
                <div class="pin-error" id="pinError"></div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title"> Parametri Angoli - <span id="settingsBowType">Olimpico</span></span>
                <button class="modal-close" id="settingsModalClose"></button>
            </div>
            <div class="modal-body">
                <div class="settings-section">
                    <div class="settings-section-title">Soglie Allineamenti (gradi)</div>
                    
                    <div class="settings-row">
                        <span class="settings-label">
                            <span class="color-dot" style="background: #ff6b6b;"></span>
                            Spalle
                        </span>
                        <div class="settings-inputs">
                            <div>
                                <input type="number" class="settings-input" id="shouldersGood" value="3">
                                <div class="settings-input-label">Buono</div>
                            </div>
                            <div>
                                <input type="number" class="settings-input" id="shouldersWarning" value="7">
                                <div class="settings-input-label">Attenzione</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="settings-row">
                        <span class="settings-label">
                            <span class="color-dot" style="background: #4ecdc4;"></span>
                            Fianchi
                        </span>
                        <div class="settings-inputs">
                            <div>
                                <input type="number" class="settings-input" id="hipsGood" value="3">
                                <div class="settings-input-label">Buono</div>
                            </div>
                            <div>
                                <input type="number" class="settings-input" id="hipsWarning" value="7">
                                <div class="settings-input-label">Attenzione</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="settings-row">
                        <span class="settings-label">
                            <span class="color-dot" style="background: #ffe66d;"></span>
                            Braccio Arco
                        </span>
                        <div class="settings-inputs">
                            <div>
                                <input type="number" class="settings-input" id="bowArmGood" value="10">
                                <div class="settings-input-label">Buono</div>
                            </div>
                            <div>
                                <input type="number" class="settings-input" id="bowArmWarning" value="20">
                                <div class="settings-input-label">Attenzione</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="settings-row">
                        <span class="settings-label">
                            <span class="color-dot" style="background: #dda0dd;"></span>
                            Busto
                        </span>
                        <div class="settings-inputs">
                            <div>
                                <input type="number" class="settings-input" id="torsoGood" value="5">
                                <div class="settings-input-label">Buono</div>
                            </div>
                            <div>
                                <input type="number" class="settings-input" id="torsoWarning" value="10">
                                <div class="settings-input-label">Attenzione</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="settings-row">
                        <span class="settings-label">
                            <span class="color-dot" style="background: #87ceeb;"></span>
                            Testa
                        </span>
                        <div class="settings-inputs">
                            <div>
                                <input type="number" class="settings-input" id="headGood" value="5">
                                <div class="settings-input-label">Buono</div>
                            </div>
                            <div>
                                <input type="number" class="settings-input" id="headWarning" value="10">
                                <div class="settings-input-label">Attenzione</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="settingsReset">Ripristina</button>
                <button class="btn btn-primary" id="settingsSave">Salva</button>
            </div>
        </div>
    </div>
    
    <!-- Athletes Modal -->
    <div class="modal-overlay" id="athletesModal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title"> Gestione Atleti</span>
                <button class="modal-close" id="athletesModalClose"></button>
            </div>
            <div class="modal-body">
                <div class="athletes-list" id="athletesList">
                    <!-- Athletes will be listed here -->
                </div>
                
                <div class="settings-section">
                    <div class="settings-section-title">Nuovo Atleta</div>
                    <div class="form-group">
                        <label class="form-label">Nome *</label>
                        <input type="text" class="form-input" id="newAthleteName" placeholder="Nome e Cognome">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Tipo Arco *</label>
                        <select class="form-select" id="newAthleteBow">
                            <option value="olympic">Olimpico</option>
                            <option value="compound">Compound</option>
                            <option value="barebow">Nudo</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="athleteDeselect">Nessun Atleta</button>
                <button class="btn btn-primary" id="athleteAdd">Aggiungi</button>
            </div>
        </div>
    </div>
    
    <!-- Set PIN Modal -->
    <div class="modal-overlay" id="setPinModal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title"> Imposta PIN</span>
                <button class="modal-close" id="setPinModalClose"></button>
            </div>
            <div class="modal-body">
                <p style="text-align: center; color: var(--text-secondary); margin-bottom: 1rem;">
                    Nessun PIN impostato. Crea un PIN a 4 cifre per proteggere la gestione atleti.
                </p>
                <div class="pin-container">
                    <input type="password" class="pin-input" maxlength="1" data-newpin="0">
                    <input type="password" class="pin-input" maxlength="1" data-newpin="1">
                    <input type="password" class="pin-input" maxlength="1" data-newpin="2">
                    <input type="password" class="pin-input" maxlength="1" data-newpin="3">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="setPinSave">Imposta PIN</button>
            </div>
        </div>
    </div>
    
    <!-- Manual Modal -->
    <div class="modal-overlay" id="manualModal">
        <div class="modal" style="max-width: 750px; max-height: 85vh;">
            <div class="modal-header">
                <span class="modal-title"> Manuale d'Uso</span>
                <button class="modal-close" id="manualModalClose"></button>
            </div>
            <div class="modal-body manual-content">
                <h2>Analisi Arciere</h2>
                <p><strong>Polisportiva Gonone Dorgali - Tiro con l'Arco</strong></p>
                <p>Applicazione per l'analisi della postura degli arcieri con intelligenza artificiale.</p>
                
                <h3> Primo Avvio</h3>
                <ol>
                    <li>Attendi il caricamento del modello AI (Holistic di default)</li>
                    <li>Consenti l'accesso alla fotocamera</li>
                    <li>Posizionati in modo da essere inquadrato completamente</li>
                </ol>
                
                <h3> Modelli AI Disponibili</h3>
                <ul>
                    <li><strong>Holistic</strong> - Completo: corpo, mani e viso (default)</li>
                    <li><strong>Lightning</strong> - Veloce: solo corpo, ideale per dispositivi lenti</li>
                    <li><strong>BodyPix</strong> - Segmentazione: silhouette del corpo</li>
                </ul>
                
                <h3> Colori Scheletro</h3>
                <ul>
                    <li><span style="color:#ff6b6b"></span> <strong>Spalle</strong> - Rosso</li>
                    <li><span style="color:#4ecdc4"></span> <strong>Fianchi</strong> - Turchese</li>
                    <li><span style="color:#ffe66d"></span> <strong>Braccio Arco</strong> - Giallo</li>
                    <li><span style="color:#95e1d3"></span> <strong>Braccio Trazione</strong> - Verde acqua</li>
                    <li><span style="color:#dda0dd"></span> <strong>Busto</strong> - Viola</li>
                    <li><span style="color:#ff9f43"></span> <strong>Collo</strong> - Arancione</li>
                    <li><span style="color:#87ceeb"></span> <strong>Testa/Viso</strong> - Azzurro</li>
                    <li><span style="color:#ffcc00"></span> <strong>Mani</strong> - Giallo oro</li>
                    <li><span style="color:#ffffff"></span> <strong>Gambe</strong> - Bianco</li>
                </ul>
                
                <h3> Registrazione e Analisi</h3>
                <ol>
                    <li><strong>Registra</strong>: premi il pulsante rosso </li>
                    <li>Il video includer ci che vedi (scheletro, griglia se attivi)</li>
                    <li><strong>Per video pulito</strong>: disattiva scheletro prima di registrare</li>
                    <li><strong>Analisi AI</strong>: sul video registrato, clicca l'icona AI e scegli il modello</li>
                </ol>
                
                <h3> Elaborazioni (Sottoprodotti)</h3>
                <p>Ogni analisi AI crea un <strong>sottoprodotto</strong> sotto il video originale:</p>
                <ul>
                    <li><span style="background:#9b59b6;color:white;padding:2px 6px;border-radius:4px;font-weight:bold">H</span> Holistic (viola)</li>
                    <li><span style="background:#f39c12;color:white;padding:2px 6px;border-radius:4px;font-weight:bold">L</span> Lightning (arancione)</li>
                    <li><span style="background:#3498db;color:white;padding:2px 6px;border-radius:4px;font-weight:bold">B</span> BodyPix (blu)</li>
                </ul>
                <p>Icone: <strong></strong> = griglia attiva, <strong></strong> = info angoli attive</p>
                <p>Clicca sul video originale o su un'elaborazione per visualizzarla.</p>
                <p><strong>Download</strong>: puoi scaricare sia l'originale che le elaborazioni (con scheletro/griglia incorporati).</p>
                
                <h3> Griglia</h3>
                <ul>
                    <li>Nel <strong>live</strong>: seleziona densit dal menu laterale</li>
                    <li>Nel <strong>playback</strong>: clicca icona griglia per menu densit (OFF, 8, 16, 24, 32, 48)</li>
                </ul>
                
                <h3> Impostazioni</h3>
                <ul>
                    <li><strong>Ingranaggio</strong>: configura soglie angoli per tipo arco</li>
                    <li><strong>Atleti</strong>: gestisci lista arcieri</li>
                    <li><strong>Tipo Arco</strong>: Olimpico, Compound, Barebow</li>
                    <li><strong>Mano</strong>: Destro o Mancino</li>
                </ul>
                
                <h3> Schermo Intero</h3>
                <p>In fullscreen, usa il menu hamburger () per accedere a tutti i controlli.</p>
                
                <h3> Risoluzione Problemi</h3>
                <ul>
                    <li><strong>Fotocamera non funziona</strong>: verifica permessi browser</li>
                    <li><strong>Scheletro non appare</strong>: migliora illuminazione, inquadrati completamente</li>
                    <li><strong>App lenta</strong>: usa modello Lightning</li>
                    <li><strong>Analisi bloccata</strong>: ricarica la pagina e riprova</li>
                </ul>
                
                <hr style="margin: 2rem 0; border-color: var(--border-color);">
                
                <h3> Changelog</h3>
                
                <div style="max-height: 200px; overflow-y: auto; font-size: 0.85rem;">
                    <p><strong>v42</strong> - Server HTTPS con certificato, archivio sicuro da app</p>
                    <p><strong>v41</strong> - Archivio Server: gestione atleti/video su PC, analisi FpF remota, upload video</p>
                    <p><strong>v39</strong> - Server locale per analisi video lunghi, qualit massima, UI configurazione server</p>
                    <p><strong>v37</strong> - Fix analisi FpF, pulsante AI con testo</p>
                    <p><strong>v36</strong> - Fix video stabile, playback controls 2 righe visibili, menu fullscreen completo</p>
                    <p><strong>v35</strong> - Fix video stabile, menu dropdown fixed, playback 2 righe, controlli playback in fullscreen</p>
                    <p><strong>v34</strong> - Header hamburger a fianco titolo, fix deformazione video, fullscreen in playback</p>
                    <p><strong>v33</strong> - UI compatta: header con hamburger, playback controls in fullscreen, fix deformazione</p>
                    <p><strong>v32</strong> - Export video a 3 fasi (estrazioneanalisicomposizione), pi stabile</p>
                    <p><strong>v31</strong> - Export video con AI in tempo reale (massima qualit), manuale PDF</p>
                    <p><strong>v30</strong> - Download elaborazioni con scheletro/griglia</p>
                    <p><strong>v29</strong> - Elaborazioni come sottoprodotti, fix griglia playback</p>
                    <p><strong>v28</strong> - Dropdown griglia, durata e note registrazioni, launcher semplificato</p>
                    <p><strong>v27</strong> - Holistic identico live/playback</p>
                    <p><strong>v26</strong> - Holistic mani+faccia nel frame-by-frame</p>
                    <p><strong>v25</strong> - Griglia in playback</p>
                    <p><strong>v24</strong> - Menu selezione modello per analisi</p>
                    <p><strong>v23</strong> - Fix analisi, scheletro OFF = AI OFF</p>
                    <p><strong>v22</strong> - Launcher con storico versioni</p>
                    <p><strong>v21</strong> - 3 modelli AI: Holistic, Lightning, BodyPix</p>
                    <p><strong>v20</strong> - Gestione atleti, parametri angoli personalizzabili</p>
                    <p><strong>v19</strong> - Overlay angoli, linea collo</p>
                    <p><strong>v18</strong> - Scheletro colorato per segmento</p>
                    <p><strong>v17</strong> - Griglia configurabile</p>
                    <p><strong>v16</strong> - Analisi frame-by-frame</p>
                    <p><strong>v15</strong> - Playback registrazioni</p>
                    <p><strong>v14</strong> - Registrazione video</p>
                    <p><strong>v11-13</strong> - Interfaccia base, detection pose</p>
                </div>
                
                <p style="text-align: center; margin-top: 2rem; color: var(--text-muted);">
                    <em>Versione 42 - Dicembre 2025</em>
                </p>
            </div>
        </div>
    </div>
    
    <!-- Versions Modal -->
    <div class="modal-overlay" id="versionsModal">
        <div class="modal" style="max-width: 500px;">
            <div class="modal-header">
                <span class="modal-title"> Versioni App</span>
                <button class="modal-close" id="versionsModalClose"></button>
            </div>
            <div class="modal-body">
                <!-- Install PWA Button -->
                <div id="installSection" style="display: none; margin-bottom: 1.5rem; padding: 1rem; background: rgba(37, 99, 235, 0.1); border-radius: 10px; border: 1px solid var(--accent-current);">
                    <p style="margin-bottom: 0.75rem; font-weight: 500;"> Installa l'app sul dispositivo</p>
                    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 1rem;">Funzioner offline e avrai accesso rapido dalla home.</p>
                    <button class="btn btn-primary" id="installBtn" style="width: 100%;">Installa Analisi Arciere</button>
                </div>
                
                <p style="margin-bottom: 1rem; color: var(--text-secondary);">
                    Seleziona una versione da utilizzare. La versione corrente  evidenziata.
                </p>
                
                <div class="versions-list">
                    <a href="app.html" class="version-item current">
                        <span class="version-badge">v27</span>
                        <span class="version-info">
                            <span class="version-name">Corrente</span>
                            <span class="version-desc">Holistic identico live/playback</span>
                        </span>
                    </a>
                    <a href="v26.html" class="version-item">
                        <span class="version-badge">v26</span>
                        <span class="version-info">
                            <span class="version-name">Holistic mani+faccia</span>
                            <span class="version-desc">Griglia regolabile playback</span>
                        </span>
                    </a>
                    <a href="v25.html" class="version-item">
                        <span class="version-badge">v25</span>
                        <span class="version-info">
                            <span class="version-name">Griglia Playback</span>
                            <span class="version-desc">Toggle griglia in playback</span>
                        </span>
                    </a>
                    <a href="v24.html" class="version-item">
                        <span class="version-badge">v24</span>
                        <span class="version-info">
                            <span class="version-name">Selezione Modello</span>
                            <span class="version-desc">Scegli modello per analisi</span>
                        </span>
                    </a>
                    <a href="v23.html" class="version-item">
                        <span class="version-badge">v23</span>
                        <span class="version-info">
                            <span class="version-name">Fix Analisi</span>
                            <span class="version-desc">Scheletro OFF = AI OFF</span>
                        </span>
                    </a>
                    <a href="v22.html" class="version-item">
                        <span class="version-badge">v22</span>
                        <span class="version-info">
                            <span class="version-name">5 Modelli AI</span>
                            <span class="version-desc">Launcher, Holistic default</span>
                        </span>
                    </a>
                    <a href="v21.html" class="version-item">
                        <span class="version-badge">v21</span>
                        <span class="version-info">
                            <span class="version-name">UltraLight Default</span>
                            <span class="version-desc">BlazePose Lite per telefoni</span>
                        </span>
                    </a>
                    <a href="v20.html" class="version-item">
                        <span class="version-badge">v20</span>
                        <span class="version-info">
                            <span class="version-name">PWA</span>
                            <span class="version-desc">Installabile, archivio club, offline</span>
                        </span>
                    </a>
                    <a href="v19.html" class="version-item">
                        <span class="version-badge">v19</span>
                        <span class="version-info">
                            <span class="version-name">Registrazione Canvas</span>
                            <span class="version-desc">Analisi frame per frame</span>
                        </span>
                    </a>
                    <a href="v18.html" class="version-item">
                        <span class="version-badge">v18</span>
                        <span class="version-info">
                            <span class="version-name">Atleti & Config</span>
                            <span class="version-desc">Gestione atleti, parametri angoli</span>
                        </span>
                    </a>
                    <a href="v17.html" class="version-item">
                        <span class="version-badge">v17</span>
                        <span class="version-info">
                            <span class="version-name">Fullscreen</span>
                            <span class="version-desc">Menu hamburger, mobile ottimizzato</span>
                        </span>
                    </a>
                    <a href="v16.html" class="version-item">
                        <span class="version-badge">v16</span>
                        <span class="version-info">
                            <span class="version-name">Colori Scheletro</span>
                            <span class="version-desc">Colori per segmento corporeo</span>
                        </span>
                    </a>
                    <a href="v15.html" class="version-item">
                        <span class="version-badge">v15</span>
                        <span class="version-info">
                            <span class="version-name">Overlay Angoli</span>
                            <span class="version-desc">Toggle allineamenti, logo grande</span>
                        </span>
                    </a>
                    <a href="v14.html" class="version-item">
                        <span class="version-badge">v14</span>
                        <span class="version-info">
                            <span class="version-name">Branding</span>
                            <span class="version-desc">Logo polisportiva, nuovo nome</span>
                        </span>
                    </a>
                    <a href="v13.html" class="version-item">
                        <span class="version-badge">v13</span>
                        <span class="version-info">
                            <span class="version-name">Angoli Video</span>
                            <span class="version-desc">Overlay angoli, linea collo</span>
                        </span>
                    </a>
                    <a href="v12.html" class="version-item">
                        <span class="version-badge">v12</span>
                        <span class="version-info">
                            <span class="version-name">Griglia</span>
                            <span class="version-desc">Griglia solo linee, densit variabile</span>
                        </span>
                    </a>
                    <a href="v11.html" class="version-item">
                        <span class="version-badge">v11</span>
                        <span class="version-info">
                            <span class="version-name">Multi-Modello</span>
                            <span class="version-desc">Holistic, BodyPix, pulsante griglia</span>
                        </span>
                    </a>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Archivio Server Modal -->
    <div class="modal-overlay" id="archivioModal">
        <div class="modal" style="max-width: 600px; max-height: 85vh;">
            <div class="modal-header">
                <span class="modal-title"> Archivio Server</span>
                <button class="modal-close" id="archivioModalClose"></button>
            </div>
            <div class="modal-body" style="padding: 0;">
                <!-- Tabs -->
                <div class="archivio-tabs">
                    <button class="archivio-tab active" data-tab="atleti"> Atleti</button>
                    <button class="archivio-tab" data-tab="video"> Video</button>
                </div>
                
                <!-- Tab Atleti -->
                <div class="archivio-content" id="tabAtleti">
                    <div class="archivio-toolbar">
                        <input type="text" id="nuovoAtletaNome" placeholder="Nome nuovo atleta..." class="archivio-input">
                        <button class="archivio-btn-add" id="btnAggiungiAtleta">+ Aggiungi</button>
                    </div>
                    <div class="archivio-list" id="listaAtleti">
                        <div class="archivio-empty">Connetti al server per vedere gli atleti</div>
                    </div>
                </div>
                
                <!-- Tab Video -->
                <div class="archivio-content" id="tabVideo" style="display: none;">
                    <div class="archivio-header-back">
                        <button class="archivio-btn-back" id="btnTornaAtleti"> Atleti</button>
                        <span id="nomeAtletaCorrente">-</span>
                    </div>
                    <div class="archivio-list" id="listaVideo">
                        <div class="archivio-empty">Seleziona un atleta</div>
                    </div>
                </div>
                
                <!-- Azioni per video selezionato dalla lista locale -->
                <div class="archivio-actions" id="archivioActions" style="display: none;">
                    <div class="archivio-selected-info">
                        <span id="selectedVideoInfo">Nessun video selezionato</span>
                    </div>
                    <div class="archivio-action-buttons">
                        <button class="archivio-btn" id="btnInviaVideo"> Invia al Server</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <img src="logo-pol.png" alt="Logo" class="loading-logo">
        <div class="loading-spinner"></div>
        <div class="loading-text">Caricamento modello AI...</div>
    </div>
    
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <div class="logo">
                <img src="logo-pol.png" alt="Logo" class="header-logo">
                Analisi Arciere
            </div>
            
            <div style="position: relative;">
                <button class="header-hamburger" id="headerHamburger">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                
                <div class="header-dropdown" id="headerDropdown">
                    <div class="header-menu-section">
                        <div class="header-menu-title">Tipo Arco</div>
                        <div class="header-menu-buttons">
                            <button class="header-menu-btn hdr-bow-btn active" data-bow="olympic">Olimpico</button>
                            <button class="header-menu-btn hdr-bow-btn" data-bow="compound">Compound</button>
                            <button class="header-menu-btn hdr-bow-btn" data-bow="barebow">Nudo</button>
                        </div>
                    </div>
                    
                    <div class="header-menu-section">
                        <div class="header-menu-title">Mano Arco</div>
                        <div class="header-menu-buttons">
                            <button class="header-menu-btn hdr-stance-btn" data-stance="left"> Mancino</button>
                            <button class="header-menu-btn hdr-stance-btn active" data-stance="right">Destro </button>
                        </div>
                    </div>
                    
                    <div class="header-menu-section">
                    <div class="header-menu-title">Azioni</div>
                    <div class="header-menu-buttons">
                        <button class="header-menu-btn icon-btn" id="hdrAthleteBtn">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2"/>
                                <circle cx="12" cy="7" r="4"/>
                            </svg>
                            Atleti
                        </button>
                        <button class="header-menu-btn icon-btn" id="hdrSettingsBtn">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="3"/>
                                <path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"/>
                            </svg>
                            Parametri
                        </button>
                        <button class="header-menu-btn icon-btn" id="hdrHelpBtn">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <path d="M9.09 9a3 3 0 015.83 1c0 2-3 3-3 3"/>
                                <line x1="12" y1="17" x2="12.01" y2="17"/>
                            </svg>
                            Manuale
                        </button>
                    </div>
                </div>
            </div>
        </div>
        </div>
        
        <div class="header-athlete">
            <span id="currentAthleteName">Nessun atleta</span>
        </div>
    </header>
    
    <!-- Main Content -->
    <main class="main-container">
        <!-- Video Section -->
        <section class="video-section">
            <div class="video-container">
                <video id="videoElement" autoplay playsinline muted></video>
                <video id="playbackVideo" playsinline></video>
                <canvas id="canvas"></canvas>
                
                <!-- Hamburger Menu Button -->
                <button class="hamburger-menu" id="hamburgerBtn">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                
                <!-- Menu Overlay -->
                <div class="menu-overlay" id="menuOverlay"></div>
                
                <!-- Fullscreen Menu -->
                <div class="fullscreen-menu" id="fullscreenMenu">
                    <div class="fs-menu-section">
                        <div class="fs-menu-title">Tipo Arco</div>
                        <div class="fs-menu-buttons">
                            <button class="fs-menu-btn fs-bow-btn active" data-bow="olympic">Olimpico</button>
                            <button class="fs-menu-btn fs-bow-btn" data-bow="compound">Compound</button>
                            <button class="fs-menu-btn fs-bow-btn" data-bow="barebow">Nudo</button>
                        </div>
                    </div>
                    
                    <div class="fs-menu-section">
                        <div class="fs-menu-title">Posizione Arciere</div>
                        <div class="fs-menu-buttons">
                            <button class="fs-menu-btn fs-stance-btn" data-stance="left"> Sinistra</button>
                            <button class="fs-menu-btn fs-stance-btn active" data-stance="right">Destra </button>
                        </div>
                    </div>
                    
                    <div class="fs-menu-section">
                        <div class="fs-menu-title">Modello AI</div>
                        <div class="fs-menu-grid">
                            <button class="fs-menu-btn fs-model-btn active" data-model="holistic">Holistic</button>
                            <button class="fs-menu-btn fs-model-btn" data-model="lightning">Lightning</button>
                            <button class="fs-menu-btn fs-model-btn" data-model="bodypix">BodyPix</button>
                        </div>
                    </div>
                    
                    <div class="fs-menu-section">
                        <div class="fs-menu-title">Visualizzazione</div>
                        <div class="fs-menu-grid">
                            <button class="fs-menu-btn fs-toggle-btn active" id="fsSkeletonBtn">Scheletro</button>
                            <button class="fs-menu-btn fs-toggle-btn" id="fsGridBtn">Griglia</button>
                            <button class="fs-menu-btn fs-toggle-btn active" id="fsAlignBtn">Allineamenti</button>
                            <button class="fs-menu-btn fs-toggle-btn" id="fsFlipBtn">Specchia</button>
                        </div>
                    </div>
                    
                    <div class="fs-menu-section">
                        <div class="fs-menu-title">Griglia</div>
                        <div class="fs-menu-buttons">
                            <button class="fs-menu-btn fs-grid-density" data-density="8">88</button>
                            <button class="fs-menu-btn fs-grid-density active" data-density="16">1616</button>
                            <button class="fs-menu-btn fs-grid-density" data-density="32">3232</button>
                        </div>
                    </div>
                    
                    <div class="fs-menu-section">
                        <div class="fs-menu-title">Azioni</div>
                        <div class="fs-menu-grid">
                            <button class="fs-menu-btn" id="fsRecordBtn"> Registra</button>
                            <button class="fs-menu-btn" id="fsScreenshotBtn"> Screenshot</button>
                        </div>
                    </div>
                    
                    <!-- Controlli Playback in Fullscreen - SEMPRE VISIBILI QUANDO IN PLAYBACK -->
                    <div class="fs-menu-section" id="fsPlaybackSection" style="display:none;">
                        <div class="fs-menu-title"> Controlli Playback</div>
                        
                        <!-- Navigazione -->
                        <div class="fs-menu-grid">
                            <button class="fs-menu-btn" id="fsBackToLiveBtn"> Torna Live</button>
                        </div>
                        
                        <div class="fs-menu-grid" style="margin-top:0.5rem;">
                            <button class="fs-menu-btn" id="fsFramePrevBtn"> Frame -1</button>
                            <button class="fs-menu-btn" id="fsPlayPauseBtn"> Play</button>
                            <button class="fs-menu-btn" id="fsFrameNextBtn"> Frame +1</button>
                        </div>
                        
                        <!-- Velocit -->
                        <div class="fs-menu-title" style="margin-top:0.75rem;"> Velocit</div>
                        <div class="fs-menu-buttons">
                            <button class="fs-menu-btn fs-speed-btn" data-speed="0.1">0.1x</button>
                            <button class="fs-menu-btn fs-speed-btn" data-speed="0.25">0.25x</button>
                            <button class="fs-menu-btn fs-speed-btn active" data-speed="0.5">0.5x</button>
                            <button class="fs-menu-btn fs-speed-btn" data-speed="1">1x</button>
                        </div>
                        
                        <!-- Griglia -->
                        <div class="fs-menu-title" style="margin-top:0.75rem;"> Griglia</div>
                        <div class="fs-menu-buttons">
                            <button class="fs-menu-btn fs-pb-grid" data-density="0">OFF</button>
                            <button class="fs-menu-btn fs-pb-grid" data-density="8">88</button>
                            <button class="fs-menu-btn fs-pb-grid active" data-density="16">1616</button>
                            <button class="fs-menu-btn fs-pb-grid" data-density="32">3232</button>
                        </div>
                        
                        <!-- Analisi AI -->
                        <div class="fs-menu-title" style="margin-top:0.75rem;"> Analisi AI</div>
                        <div class="fs-menu-buttons">
                            <button class="fs-menu-btn fs-analyze-btn" data-model="holistic">Holistic</button>
                            <button class="fs-menu-btn fs-analyze-btn" data-model="lightning">Lightning</button>
                            <button class="fs-menu-btn fs-analyze-btn" data-model="bodypix">BodyPix</button>
                        </div>
                    </div>
                    
                    <button class="fs-close-btn" id="fsExitBtn">Esci da Schermo Intero</button>
                </div>
                
                <div class="mode-indicator" id="modeIndicator">
                    <div class="mode-dot"></div>
                    <span id="modeText">Live</span>
                </div>
                
                <!-- Overlay Angoli -->
                <div class="angles-overlay" id="anglesOverlay">
                    <div class="angle-item" id="angleShoulders" data-color="#ff6b6b">
                        <span class="angle-label">Spalle</span>
                        <span class="angle-value">--</span>
                    </div>
                    <div class="angle-item" id="angleHips" data-color="#4ecdc4">
                        <span class="angle-label">Fianchi</span>
                        <span class="angle-value">--</span>
                    </div>
                    <div class="angle-item" id="angleBowArm" data-color="#ffe66d">
                        <span class="angle-label">Braccio Arco</span>
                        <span class="angle-value">--</span>
                    </div>
                    <div class="angle-item" id="angleDrawArm" data-color="#95e1d3">
                        <span class="angle-label">Braccio Trazione</span>
                        <span class="angle-value">--</span>
                    </div>
                    <div class="angle-item" id="angleTorso" data-color="#dda0dd">
                        <span class="angle-label">Busto</span>
                        <span class="angle-value">--</span>
                    </div>
                    <div class="angle-item" id="angleHead" data-color="#87ceeb">
                        <span class="angle-label">Testa</span>
                        <span class="angle-value">--</span>
                    </div>
                </div>
                
                <div class="fps-counter" id="fpsCounter">-- FPS</div>
            </div>
            
            <!-- Live Controls -->
            <div class="controls-bar" id="liveControls">
                <div class="control-group">
                    <button class="control-btn" id="flipBtn" title="Specchia video">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M8 3H5a2 2 0 00-2 2v14c0 1.1.9 2 2 2h3M16 3h3a2 2 0 012 2v14a2 2 0 01-2 2h-3M12 3v18"/>
                        </svg>
                    </button>
                    <button class="control-btn" id="skeletonBtn" title="Mostra/nascondi scheletro">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="5" r="3"/>
                            <line x1="12" y1="8" x2="12" y2="16"/>
                            <line x1="12" y1="12" x2="8" y2="9"/>
                            <line x1="12" y1="12" x2="16" y2="9"/>
                            <line x1="12" y1="16" x2="8" y2="21"/>
                            <line x1="12" y1="16" x2="16" y2="21"/>
                        </svg>
                    </button>
                    <button class="control-btn" id="gridBtn" title="Mostra/nascondi griglia">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18"/>
                            <line x1="3" y1="9" x2="21" y2="9"/>
                            <line x1="3" y1="15" x2="21" y2="15"/>
                            <line x1="9" y1="3" x2="9" y2="21"/>
                            <line x1="15" y1="3" x2="15" y2="21"/>
                        </svg>
                    </button>
                    <button class="control-btn active" id="alignmentsBtn" title="Mostra/nascondi allineamenti">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 20V10"/>
                            <path d="M18 20V4"/>
                            <path d="M6 20v-4"/>
                        </svg>
                    </button>
                    <select class="grid-density-select" id="gridDensitySelect" title="Densit griglia">
                        <option value="8">88</option>
                        <option value="16" selected>1616</option>
                        <option value="24">2424</option>
                        <option value="32">3232</option>
                        <option value="48">4848</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <button class="control-btn primary" id="recordBtn" title="Registra">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <circle cx="12" cy="12" r="8"/>
                        </svg>
                    </button>
                </div>
                
                <div class="control-group">
                    <button class="control-btn" id="screenshotBtn" title="Screenshot">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2"/>
                            <circle cx="12" cy="12" r="3"/>
                        </svg>
                    </button>
                    <button class="control-btn" id="fullscreenBtn" title="Schermo intero">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M8 3H5a2 2 0 00-2 2v3M21 8V5a2 2 0 00-2-2h-3M3 16v3a2 2 0 002 2h3M16 21h3a2 2 0 002-2v-3"/>
                        </svg>
                    </button>
                </div>
            </div>
            
            <!-- Playback Controls -->
            <div class="playback-controls" id="playbackControls">
                <!-- Timeline -->
                <div class="timeline" id="timeline">
                    <div class="timeline-progress" id="timelineProgress"></div>
                    <div class="timeline-handle" id="timelineHandle" style="left: 0%"></div>
                </div>
                
                <!-- Riga 1: Navigazione principale -->
                <div class="playback-row-1">
                    <button class="control-btn" id="backToLiveBtn" title="Torna al live">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <circle cx="12" cy="12" r="3" fill="currentColor"/>
                        </svg>
                    </button>
                    <button class="control-btn" id="framePrevBtn" title="Frame -1">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="19" y1="5" x2="19" y2="19"/>
                            <polygon points="14,19 5,12 14,5" fill="currentColor"/>
                        </svg>
                    </button>
                    <button class="control-btn primary" id="playPauseBtn" title="Play/Pausa">
                        <svg viewBox="0 0 24 24" fill="currentColor" id="playIcon">
                            <polygon points="8,5 19,12 8,19"/>
                        </svg>
                    </button>
                    <button class="control-btn" id="frameNextBtn" title="Frame +1">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="5" y1="5" x2="5" y2="19"/>
                            <polygon points="10,5 19,12 10,19" fill="currentColor"/>
                        </svg>
                    </button>
                    <div class="frame-counter" id="frameCounter">0 / 0</div>
                </div>
                
                <!-- Riga 2: Griglia, AI, Fullscreen, Velocit -->
                <div class="playback-row-2">
                    <!-- Griglia -->
                    <div class="grid-menu" id="gridMenu">
                        <button class="control-btn" id="playbackGridBtn" title="Griglia">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="18" height="18" rx="2"/>
                                <line x1="3" y1="9" x2="21" y2="9"/>
                                <line x1="3" y1="15" x2="21" y2="15"/>
                                <line x1="9" y1="3" x2="9" y2="21"/>
                                <line x1="15" y1="3" x2="15" y2="21"/>
                            </svg>
                        </button>
                        <div class="grid-dropdown" id="gridDropdown">
                            <button class="grid-option" data-density="0">OFF</button>
                            <button class="grid-option" data-density="8">88</button>
                            <button class="grid-option active" data-density="16">1616</button>
                            <button class="grid-option" data-density="32">3232</button>
                        </div>
                    </div>
                    
                    <!-- Analisi AI -->
                    <div class="analyze-menu" id="analyzeMenu">
                        <button class="control-btn analyze-btn" id="analyzeBtn" title="Analizza AI">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7z"/>
                                <circle cx="12" cy="12" r="3"/>
                            </svg>
                            <span class="analyze-text">AI</span>
                        </button>
                        <div class="analyze-dropdown" id="analyzeDropdown">
                            <button class="analyze-option" data-model="holistic">Holistic</button>
                            <button class="analyze-option" data-model="lightning">Lightning</button>
                            <button class="analyze-option" data-model="bodypix">BodyPix</button>
                        </div>
                    </div>
                    
                    <!-- Fullscreen -->
                    <button class="control-btn" id="playbackFullscreenBtn" title="Schermo intero">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M8 3H5a2 2 0 00-2 2v3M21 8V5a2 2 0 00-2-2h-3M3 16v3a2 2 0 002 2h3M16 21h3a2 2 0 002-2v-3"/>
                        </svg>
                    </button>
                    
                    <!-- Velocit -->
                    <div class="speed-control">
                        <button class="speed-btn" data-speed="0.25">.25x</button>
                        <button class="speed-btn active" data-speed="0.5">.5x</button>
                        <button class="speed-btn" data-speed="1">1x</button>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Sidebar -->
        <aside class="sidebar">
            <!-- Camera & Settings -->
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">Impostazioni</span>
                </div>
                <div class="panel-content">
                    <select class="camera-select" id="cameraSelect">
                        <option value="">Seleziona fotocamera...</option>
                    </select>
                    
                    <div style="margin-top: 1rem;">
                        <label class="panel-title" style="display: block; margin-bottom: 0.5rem;">Posizione Arciere</label>
                        <div class="stance-selector">
                            <button class="stance-btn" data-stance="left"> Sinistra</button>
                            <button class="stance-btn active" data-stance="right">Destra </button>
                        </div>
                    </div>
                    
                    <div style="margin-top: 1rem;">
                        <label class="panel-title" style="display: block; margin-bottom: 0.5rem;">Nome Atleta</label>
                        <input type="text" class="athlete-input" id="athleteName" placeholder="Nome atleta...">
                    </div>
                    
                    <div style="margin-top: 1rem;">
                        <label class="panel-title" style="display: block; margin-bottom: 0.5rem;">Modello AI</label>
                        <div class="model-selector">
                            <button class="model-btn active" data-model="holistic">
                                <span class="model-name">Holistic</span>
                                <span class="model-desc">Consigliato</span>
                            </button>
                            <button class="model-btn" data-model="lightning">
                                <span class="model-name">Lightning</span>
                                <span class="model-desc">Veloce</span>
                            </button>
                            <button class="model-btn" data-model="bodypix">
                                <span class="model-name">BodyPix</span>
                                <span class="model-desc">Segmenta</span>
                            </button>
                        </div>
                    </div>
                    
                    <!-- Server Archivio -->
                    <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                        <label class="panel-title" style="display: block; margin-bottom: 0.75rem;"> Server Archivio</label>
                        
                        <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.75rem;">
                            <input type="text" class="server-input" id="serverIP" placeholder="192.168.1.100" style="flex: 1;">
                            <span style="color: var(--text-muted);">:5000</span>
                        </div>
                        
                        <button class="server-open-btn" id="serverArchiveBtn">
                             Apri Archivio
                        </button>
                        
                        <div id="serverStatus" style="font-size: 0.75rem; text-align: center; margin-top: 0.5rem;"></div>
                    </div>
                </div>
            </div>
            
            <!-- Recordings -->
            <div class="panel">
                <div class="panel-header">
                    <span class="panel-title">Registrazioni</span>
                </div>
                <div class="panel-content">
                    <div class="recordings-list" id="recordingsList">
                        <div class="empty-state">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M3 6a2 2 0 012-2h8a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6z"/>
                            </svg>
                            <p>Nessuna registrazione</p>
                        </div>
                    </div>
                </div>
            </div>
        </aside>
    </main>

    <script>
        // App State
        const state = {
            bowType: 'olympic',
            stance: 'right', // archer facing left or right (default: right-handed)
            modelType: 'holistic', // 'holistic', 'lightning', 'ultralight', 'posenet', 'bodypix'
            useBlazePose: false, // true se stiamo usando MediaPipe/BlazePose
            isRecording: false,
            isPlayback: false,
            isPlaying: false,
            isAnalyzing: false,
            showSkeleton: true,
            showGrid: false,
            showAlignments: true,
            gridDensity: 16, // 8, 16, 24, 32
            flipVideo: false,
            detector: null,
            holisticDetector: null, // MediaPipe Holistic
            holisticCamera: null, // Camera per Holistic
            bodyPixNet: null, // BodyPix
            blazeDetector: null, // per analisi avanzata
            currentPose: null,
            currentHolisticResults: null, // risultati Holistic
            currentSegmentation: null, // risultati BodyPix
            analyzedFrames: {}, // cache frame analizzati
            recordings: [],
            currentRecording: null,
            currentElaboration: null, // elaborazione corrente in visualizzazione
            currentFrame: 0,
            playbackSpeed: 0.5,
            fps: 0,
            frameCount: 0,
            lastFpsTime: Date.now(),
            // Server settings - rileva automaticamente se siamo sul server locale
            serverMode: (window.location.port === '5000' || window.location.hostname.match(/^192\.168\./)) ? 'local' : 'offline',
            serverIP: localStorage.getItem('serverIP') || window.location.hostname || '',
            serverConnected: (window.location.port === '5000')
        };

        // DOM Elements
        const elements = {
            video: document.getElementById('videoElement'),
            playbackVideo: document.getElementById('playbackVideo'),
            canvas: document.getElementById('canvas'),
            loadingOverlay: document.getElementById('loadingOverlay'),
            modeIndicator: document.getElementById('modeIndicator'),
            modeText: document.getElementById('modeText'),
            fpsCounter: document.getElementById('fpsCounter'),
            liveControls: document.getElementById('liveControls'),
            playbackControls: document.getElementById('playbackControls'),
            recordBtn: document.getElementById('recordBtn'),
            flipBtn: document.getElementById('flipBtn'),
            skeletonBtn: document.getElementById('skeletonBtn'),
            gridBtn: document.getElementById('gridBtn'),
            screenshotBtn: document.getElementById('screenshotBtn'),
            fullscreenBtn: document.getElementById('fullscreenBtn'),
            cameraSelect: document.getElementById('cameraSelect'),
            athleteName: document.getElementById('athleteName'),
            alignmentList: document.getElementById('alignmentList'),
            recordingsList: document.getElementById('recordingsList'),
            timeline: document.getElementById('timeline'),
            timelineProgress: document.getElementById('timelineProgress'),
            timelineHandle: document.getElementById('timelineHandle'),
            frameCounter: document.getElementById('frameCounter'),
            playPauseBtn: document.getElementById('playPauseBtn'),
            framePrevBtn: document.getElementById('framePrevBtn'),
            frameNextBtn: document.getElementById('frameNextBtn'),
            backToLiveBtn: document.getElementById('backToLiveBtn')
        };

        const ctx = elements.canvas.getContext('2d');

        // Bow type configurations
        const bowConfig = {
            olympic: {
                color: '#2563eb',
                tips: [
                    { icon: 'target', text: 'Mantieni le spalle allineate con il bersaglio' },
                    { icon: 'arrow', text: 'Il braccio dell\'arco deve essere completamente esteso' },
                    { icon: 'anchor', text: 'Ancora sotto il mento, corda sul naso' },
                    { icon: 'posture', text: 'Busto eretto, leggera inclinazione in avanti' }
                ],
                thresholds: {
                    shoulders: { good: 3, warning: 7 },
                    hips: { good: 3, warning: 7 },
                    bowArm: { target: 180, good: 10, warning: 20 },
                    torso: { good: 5, warning: 10 },
                    head: { good: 5, warning: 10 }
                }
            },
            compound: {
                color: '#dc2626',
                tips: [
                    { icon: 'target', text: 'Spalle parallele, stance leggermente aperto' },
                    { icon: 'arrow', text: 'Gomito del braccio arco leggermente piegato' },
                    { icon: 'anchor', text: 'Ancora al lato del viso, usa il peep sight' },
                    { icon: 'posture', text: 'Postura pi rilassata rispetto all\'olimpico' }
                ],
                thresholds: {
                    shoulders: { good: 5, warning: 10 },
                    hips: { good: 5, warning: 10 },
                    bowArm: { target: 170, good: 15, warning: 25 },
                    torso: { good: 7, warning: 12 },
                    head: { good: 7, warning: 12 }
                }
            },
            barebow: {
                color: '#16a34a',
                tips: [
                    { icon: 'target', text: 'Allineamento simile all\'olimpico' },
                    { icon: 'arrow', text: 'Stringwalk o facewalking per la mira' },
                    { icon: 'anchor', text: 'Ancora costante, spesso pi alta' },
                    { icon: 'posture', text: 'Postura stabile, piedi ben piantati' }
                ],
                thresholds: {
                    shoulders: { good: 3, warning: 7 },
                    hips: { good: 3, warning: 7 },
                    bowArm: { target: 180, good: 10, warning: 20 },
                    torso: { good: 5, warning: 10 },
                    head: { good: 5, warning: 10 }
                }
            }
        };
        
        // Default thresholds (per reset)
        const defaultThresholds = JSON.parse(JSON.stringify(bowConfig));
        
        // Athletes storage
        let athletes = JSON.parse(localStorage.getItem('archeryAthletes') || '[]');
        let currentAthlete = JSON.parse(localStorage.getItem('archeryCurrentAthlete') || 'null');
        let appPin = localStorage.getItem('archeryPin') || null;
        
        // Load saved thresholds
        function loadSavedThresholds() {
            const saved = localStorage.getItem('archeryThresholds');
            if (saved) {
                const savedThresholds = JSON.parse(saved);
                Object.keys(savedThresholds).forEach(bowType => {
                    if (bowConfig[bowType]) {
                        bowConfig[bowType].thresholds = savedThresholds[bowType];
                    }
                });
            }
        }
        loadSavedThresholds();
        
        // Save thresholds
        function saveThresholds() {
            const thresholds = {};
            Object.keys(bowConfig).forEach(bowType => {
                thresholds[bowType] = bowConfig[bowType].thresholds;
            });
            localStorage.setItem('archeryThresholds', JSON.stringify(thresholds));
        }
        
        // Save athletes
        function saveAthletes() {
            localStorage.setItem('archeryAthletes', JSON.stringify(athletes));
        }
        
        // Save current athlete
        function saveCurrentAthlete() {
            localStorage.setItem('archeryCurrentAthlete', JSON.stringify(currentAthlete));
            document.getElementById('currentAthleteName').textContent = 
                currentAthlete ? currentAthlete.name : 'Nessun atleta';
        }

        // Smoothing system
        const smoothingBuffer = {};
        const SMOOTHING_FRAMES = 8; // numero di frame per la media mobile (aumentato per Thunder)
        
        function smoothKeypoints(keypoints) {
            return keypoints.map((kp, index) => {
                if (!smoothingBuffer[index]) {
                    smoothingBuffer[index] = [];
                }
                
                smoothingBuffer[index].push({ x: kp.x, y: kp.y, score: kp.score });
                
                // Mantieni solo gli ultimi N frame
                if (smoothingBuffer[index].length > SMOOTHING_FRAMES) {
                    smoothingBuffer[index].shift();
                }
                
                // Calcola la media
                const buffer = smoothingBuffer[index];
                const avgX = buffer.reduce((sum, p) => sum + p.x, 0) / buffer.length;
                const avgY = buffer.reduce((sum, p) => sum + p.y, 0) / buffer.length;
                const avgScore = buffer.reduce((sum, p) => sum + p.score, 0) / buffer.length;
                
                return {
                    ...kp,
                    x: avgX,
                    y: avgY,
                    score: avgScore
                };
            });
        }
        
        // Keypoint indices for MoveNet
        const KEYPOINTS = {
            nose: 0,
            leftEye: 1,
            rightEye: 2,
            leftEar: 3,
            rightEar: 4,
            leftShoulder: 5,
            rightShoulder: 6,
            leftElbow: 7,
            rightElbow: 8,
            leftWrist: 9,
            rightWrist: 10,
            leftHip: 11,
            rightHip: 12,
            leftKnee: 13,
            rightKnee: 14,
            leftAnkle: 15,
            rightAnkle: 16
        };

        // Skeleton connections
        const SKELETON_CONNECTIONS = [
            [KEYPOINTS.leftShoulder, KEYPOINTS.rightShoulder],
            [KEYPOINTS.leftShoulder, KEYPOINTS.leftElbow],
            [KEYPOINTS.leftElbow, KEYPOINTS.leftWrist],
            [KEYPOINTS.rightShoulder, KEYPOINTS.rightElbow],
            [KEYPOINTS.rightElbow, KEYPOINTS.rightWrist],
            [KEYPOINTS.leftShoulder, KEYPOINTS.leftHip],
            [KEYPOINTS.rightShoulder, KEYPOINTS.rightHip],
            [KEYPOINTS.leftHip, KEYPOINTS.rightHip],
            [KEYPOINTS.leftHip, KEYPOINTS.leftKnee],
            [KEYPOINTS.leftKnee, KEYPOINTS.leftAnkle],
            [KEYPOINTS.rightHip, KEYPOINTS.rightKnee],
            [KEYPOINTS.rightKnee, KEYPOINTS.rightAnkle],
            [KEYPOINTS.nose, KEYPOINTS.leftEye],
            [KEYPOINTS.nose, KEYPOINTS.rightEye],
            [KEYPOINTS.leftEye, KEYPOINTS.leftEar],
            [KEYPOINTS.rightEye, KEYPOINTS.rightEar]
        ];

        // Initialize app
        async function loadModel(modelType) {
            // Dispose modelli precedenti
            if (state.detector) {
                try { state.detector.dispose(); } catch(e) {}
                state.detector = null;
            }
            if (state.holisticDetector) {
                try { state.holisticDetector.close(); } catch(e) {}
                state.holisticDetector = null;
            }
            if (state.holisticCamera) {
                try { state.holisticCamera.stop(); } catch(e) {}
                state.holisticCamera = null;
            }
            state.bodyPixNet = null;
            state.modelType = modelType;
            
            if (modelType === 'holistic') {
                // MediaPipe Holistic
                try {
                    const holistic = new Holistic({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic@0.5.1675471629/${file}`
                    });
                    
                    holistic.setOptions({
                        modelComplexity: 1,
                        smoothLandmarks: true,
                        enableSegmentation: false,
                        smoothSegmentation: false,
                        refineFaceLandmarks: false,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });
                    
                    holistic.onResults((results) => {
                        state.currentHolisticResults = results;
                    });
                    
                    state.holisticDetector = holistic;
                    console.log('MediaPipe Holistic configurato');
                } catch (e) {
                    console.error('Errore Holistic:', e);
                    state.detector = await poseDetection.createDetector(
                        poseDetection.SupportedModels.MoveNet,
                        { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING, enableSmoothing: true }
                    );
                    state.modelType = 'lightning';
                    alert('Holistic non disponibile, uso Lightning');
                }
            } else if (modelType === 'bodypix') {
                // BodyPix - segmentazione corporea
                try {
                    state.bodyPixNet = await bodyPix.load({
                        architecture: 'MobileNetV1',
                        outputStride: 16,
                        multiplier: 0.75,
                        quantBytes: 2
                    });
                    console.log('BodyPix caricato');
                } catch (e) {
                    console.error('Errore BodyPix:', e);
                    state.detector = await poseDetection.createDetector(
                        poseDetection.SupportedModels.MoveNet,
                        { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING, enableSmoothing: true }
                    );
                    state.modelType = 'lightning';
                    alert('BodyPix non disponibile, uso Lightning');
                }
            } else {
                // MoveNet Lightning (default)
                state.detector = await poseDetection.createDetector(
                    poseDetection.SupportedModels.MoveNet,
                    { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING, enableSmoothing: true }
                );
            }
            
            // Resetta il buffer di smoothing
            Object.keys(smoothingBuffer).forEach(key => delete smoothingBuffer[key]);
        }
        
        async function init() {
            try {
                // Load MoveNet model
                await loadModel(state.modelType);
                
                // Get cameras
                await populateCameras();
                
                // Setup event listeners
                setupEventListeners();
                
                // Hide loading
                elements.loadingOverlay.classList.add('hidden');
                
                // Start with default camera
                if (elements.cameraSelect.options.length > 1) {
                    elements.cameraSelect.selectedIndex = 1;
                    await startCamera(elements.cameraSelect.value);
                }
            } catch (error) {
                console.error('Initialization error:', error);
                elements.loadingOverlay.querySelector('.loading-text').textContent = 
                    'Errore di caricamento. Ricarica la pagina.';
            }
        }

        async function populateCameras() {
            // Prima richiedi i permessi, altrimenti il browser non mostra tutte le fotocamere
            try {
                const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
                // Chiudi subito lo stream temporaneo
                tempStream.getTracks().forEach(track => track.stop());
            } catch (e) {
                console.log('Permesso fotocamera non concesso');
            }
            
            // Ora enumera tutte le fotocamere
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(d => d.kind === 'videoinput');
            
            elements.cameraSelect.innerHTML = '<option value="">Seleziona fotocamera...</option>';
            videoDevices.forEach((device, index) => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.textContent = device.label || `Camera ${index + 1}`;
                elements.cameraSelect.appendChild(option);
            });
            
            console.log(`Trovate ${videoDevices.length} fotocamere`);
        }

        async function startCamera(deviceId) {
            try {
                // Ferma lo stream precedente se esiste
                if (elements.video.srcObject) {
                    const tracks = elements.video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    elements.video.srcObject = null;
                }
                
                // Resetta il buffer di smoothing quando si cambia camera
                Object.keys(smoothingBuffer).forEach(key => delete smoothingBuffer[key]);
                
                const constraints = {
                    video: {
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: 60, min: 30 }
                    }
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                elements.video.srcObject = stream;
                
                elements.video.onloadedmetadata = () => {
                    updateCanvasSize();
                    if (!state.isPlayback) {
                        detectPose();
                    }
                };
            } catch (error) {
                console.error('Camera error:', error);
                alert('Impossibile accedere alla fotocamera. Verifica i permessi.');
            }
        }
        
        // Funzione per aggiornare dimensioni canvas
        function updateCanvasSize() {
            if (elements.video.videoWidth && elements.video.videoHeight) {
                elements.canvas.width = elements.video.videoWidth;
                elements.canvas.height = elements.video.videoHeight;
            }
        }
        
        // Handler per resize/orientamento
        window.addEventListener('resize', () => {
            updateCanvasSize();
        });
        
        // Handler per cambio orientamento
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                updateCanvasSize();
            }, 100);
        });
        
        // Handler per fullscreen change
        document.addEventListener('fullscreenchange', () => {
            setTimeout(() => {
                updateCanvasSize();
            }, 100);
        });

        async function detectPose() {
            if (state.isPlayback) return;
            
            if (elements.video.readyState >= 2) {
                // Se scheletro disattivato, disegna solo il video senza AI
                if (!state.showSkeleton) {
                    drawFrame(elements.video, null);
                    requestAnimationFrame(detectPose);
                    return;
                }
                
                try {
                    if (state.modelType === 'holistic' && state.holisticDetector) {
                        // MediaPipe Holistic - invia frame
                        await state.holisticDetector.send({ image: elements.video });
                        
                        // Aspetta un po' per i risultati
                        await new Promise(r => setTimeout(r, 10));
                        
                        if (state.currentHolisticResults) {
                            drawFrameHolistic(elements.video, state.currentHolisticResults);
                        } else {
                            drawFrame(elements.video, null);
                        }
                        
                    } else if (state.modelType === 'bodypix' && state.bodyPixNet) {
                        // BodyPix - segmentazione
                        const segmentation = await state.bodyPixNet.segmentPerson(elements.video, {
                            flipHorizontal: false,
                            internalResolution: 'medium',
                            segmentationThreshold: 0.7
                        });
                        state.currentSegmentation = segmentation;
                        drawFrameBodyPix(elements.video, segmentation);
                        
                    } else if (state.detector) {
                        // MoveNet Lightning
                        const poses = await state.detector.estimatePoses(elements.video);
                        
                        if (poses.length > 0) {
                            let pose = poses[0];
                            pose.keypoints = smoothKeypoints(pose.keypoints);
                            state.currentPose = pose;
                            updateAlignments(pose);
                            drawFrame(elements.video, pose);
                        } else {
                            drawFrame(elements.video, null);
                        }
                    } else {
                        drawFrame(elements.video, null);
                    }
                } catch (e) {
                    console.error('Errore detection:', e);
                    drawFrame(elements.video, null);
                }
                
                updateFps();
            }
            
            requestAnimationFrame(detectPose);
        }
        
        // Disegna frame con MediaPipe Holistic
        function drawFrameHolistic(source, results) {
            const { width, height } = elements.canvas;
            
            ctx.save();
            if (state.flipVideo) {
                ctx.translate(width, 0);
                ctx.scale(-1, 1);
            }
            ctx.drawImage(source, 0, 0, width, height);
            ctx.restore();
            
            // Disegna griglia se attiva
            if (state.showGrid) {
                drawGrid(width, height);
            }
            
            if (!results || !state.showSkeleton) return;
            
            // Colori per segmento (corrispondono agli allineamenti)
            const segmentColors = {
                shoulders: '#ff6b6b',    // rosso
                hips: '#4ecdc4',         // turchese  
                bowArm: '#ffe66d',       // giallo
                drawArm: '#95e1d3',      // verde acqua
                torso: '#dda0dd',        // viola
                head: '#87ceeb',         // azzurro
                neck: '#ff9f43',         // arancione
                hands: '#ffcc00',        // giallo oro
                legs: '#ffffff'          // bianco
            };
            
            const bowSide = state.stance === 'left' ? 'left' : 'right';
            
            ctx.save();
            if (state.flipVideo) {
                ctx.translate(width, 0);
                ctx.scale(-1, 1);
            }
            
            ctx.shadowColor = 'rgba(0,0,0,0.6)';
            ctx.shadowBlur = 4;
            ctx.lineCap = 'round';
            
            // Disegna pose (corpo) con colori per segmento
            if (results.poseLandmarks) {
                const lm = results.poseLandmarks;
                
                // Helper per disegnare linea
                const drawLine = (idx1, idx2, color, lineWidth = 6) => {
                    if (lm[idx1] && lm[idx2]) {
                        ctx.beginPath();
                        ctx.strokeStyle = color;
                        ctx.lineWidth = lineWidth;
                        ctx.moveTo(lm[idx1].x * width, lm[idx1].y * height);
                        ctx.lineTo(lm[idx2].x * width, lm[idx2].y * height);
                        ctx.stroke();
                    }
                };
                
                // Helper per disegnare punto
                const drawPoint = (idx, color, radius = 8) => {
                    if (lm[idx]) {
                        ctx.beginPath();
                        ctx.arc(lm[idx].x * width, lm[idx].y * height, radius, 0, 2 * Math.PI);
                        ctx.fillStyle = color;
                        ctx.fill();
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 0;
                        ctx.stroke();
                        ctx.shadowBlur = 4;
                    }
                };
                
                // SPALLE (rosso)
                drawLine(11, 12, segmentColors.shoulders, 8);
                drawPoint(11, segmentColors.shoulders, 10);
                drawPoint(12, segmentColors.shoulders, 10);
                
                // FIANCHI (turchese)
                drawLine(23, 24, segmentColors.hips, 8);
                drawPoint(23, segmentColors.hips, 10);
                drawPoint(24, segmentColors.hips, 10);
                
                // BUSTO (viola)
                drawLine(11, 23, segmentColors.torso, 6);
                drawLine(12, 24, segmentColors.torso, 6);
                
                // BRACCIO ARCO (giallo) - sinistro o destro in base a stance
                if (bowSide === 'left') {
                    drawLine(11, 13, segmentColors.bowArm, 6);
                    drawLine(13, 15, segmentColors.bowArm, 6);
                    drawPoint(13, segmentColors.bowArm);
                    drawPoint(15, segmentColors.bowArm);
                    // BRACCIO TRAZIONE (verde acqua)
                    drawLine(12, 14, segmentColors.drawArm, 6);
                    drawLine(14, 16, segmentColors.drawArm, 6);
                    drawPoint(14, segmentColors.drawArm);
                    drawPoint(16, segmentColors.drawArm);
                } else {
                    drawLine(12, 14, segmentColors.bowArm, 6);
                    drawLine(14, 16, segmentColors.bowArm, 6);
                    drawPoint(14, segmentColors.bowArm);
                    drawPoint(16, segmentColors.bowArm);
                    // BRACCIO TRAZIONE (verde acqua)
                    drawLine(11, 13, segmentColors.drawArm, 6);
                    drawLine(13, 15, segmentColors.drawArm, 6);
                    drawPoint(13, segmentColors.drawArm);
                    drawPoint(15, segmentColors.drawArm);
                }
                
                // COLLO (arancione)
                if (lm[11] && lm[12] && lm[0]) {
                    const midX = (lm[11].x + lm[12].x) / 2 * width;
                    const midY = (lm[11].y + lm[12].y) / 2 * height;
                    ctx.beginPath();
                    ctx.strokeStyle = segmentColors.neck;
                    ctx.lineWidth = 5;
                    ctx.moveTo(midX, midY);
                    ctx.lineTo(lm[0].x * width, lm[0].y * height);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(midX, midY, 6, 0, 2 * Math.PI);
                    ctx.fillStyle = segmentColors.neck;
                    ctx.fill();
                }
                
                // TESTA (azzurro)
                drawPoint(0, segmentColors.head, 8); // naso
                
                // GAMBE (bianco)
                drawLine(23, 25, segmentColors.legs, 5);
                drawLine(25, 27, segmentColors.legs, 5);
                drawLine(24, 26, segmentColors.legs, 5);
                drawLine(26, 28, segmentColors.legs, 5);
                drawPoint(25, segmentColors.legs, 6);
                drawPoint(27, segmentColors.legs, 6);
                drawPoint(26, segmentColors.legs, 6);
                drawPoint(28, segmentColors.legs, 6);
            }
            
            // Disegna mani (giallo oro)
            if (results.leftHandLandmarks) {
                drawHolisticConnectors(results.leftHandLandmarks, HAND_CONNECTIONS, segmentColors.hands, 3, width, height);
                drawHolisticLandmarks(results.leftHandLandmarks, segmentColors.hands, 4, width, height);
            }
            
            if (results.rightHandLandmarks) {
                drawHolisticConnectors(results.rightHandLandmarks, HAND_CONNECTIONS, segmentColors.hands, 3, width, height);
                drawHolisticLandmarks(results.rightHandLandmarks, segmentColors.hands, 4, width, height);
            }
            
            // Disegna perimetro testa (azzurro)
            if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                // Perimetro del viso (contorno ovale)
                const faceContour = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109, 10];
                
                ctx.beginPath();
                ctx.strokeStyle = '#87ceeb'; // azzurro come testa
                ctx.lineWidth = 2;
                
                faceContour.forEach((idx, i) => {
                    if (results.faceLandmarks[idx]) {
                        const lm = results.faceLandmarks[idx];
                        if (i === 0) {
                            ctx.moveTo(lm.x * width, lm.y * height);
                        } else {
                            ctx.lineTo(lm.x * width, lm.y * height);
                        }
                    }
                });
                ctx.closePath();
                ctx.stroke();
            }
            
            ctx.restore();
            
            // Converti per allineamenti
            if (results.poseLandmarks) {
                const pose = convertHolisticToMoveNet(results.poseLandmarks, width, height);
                if (pose) {
                    state.currentPose = pose;
                    updateAlignments(pose);
                }
            }
        }
        
        // Disegna frame con BodyPix
        function drawFrameBodyPix(source, segmentation) {
            const { width, height } = elements.canvas;
            
            ctx.save();
            if (state.flipVideo) {
                ctx.translate(width, 0);
                ctx.scale(-1, 1);
            }
            ctx.drawImage(source, 0, 0, width, height);
            ctx.restore();
            
            // Disegna griglia se attiva
            if (state.showGrid) {
                drawGrid(width, height);
            }
            
            if (!segmentation || !state.showSkeleton) return;
            
            const config = bowConfig[state.bowType];
            
            // Disegna maschera di segmentazione
            const maskCanvas = document.createElement('canvas');
            maskCanvas.width = width;
            maskCanvas.height = height;
            const maskCtx = maskCanvas.getContext('2d');
            
            const imageData = maskCtx.createImageData(width, height);
            const data = segmentation.data;
            
            for (let i = 0; i < data.length; i++) {
                const j = i * 4;
                if (data[i]) {
                    // Persona rilevata - colora con il colore dell'arco
                    const rgb = hexToRgb(config.color);
                    imageData.data[j] = rgb.r;
                    imageData.data[j + 1] = rgb.g;
                    imageData.data[j + 2] = rgb.b;
                    imageData.data[j + 3] = 100; // semi-trasparente
                } else {
                    imageData.data[j + 3] = 0; // trasparente
                }
            }
            
            maskCtx.putImageData(imageData, 0, 0);
            
            ctx.save();
            if (state.flipVideo) {
                ctx.translate(width, 0);
                ctx.scale(-1, 1);
            }
            ctx.drawImage(maskCanvas, 0, 0);
            ctx.restore();
            
            // BodyPix pu anche rilevare pose
            if (segmentation.allPoses && segmentation.allPoses.length > 0) {
                const pose = segmentation.allPoses[0];
                state.currentPose = { keypoints: pose.keypoints };
                updateAlignments({ keypoints: pose.keypoints });
                
                // Disegna scheletro
                ctx.save();
                if (state.flipVideo) {
                    ctx.translate(width, 0);
                    ctx.scale(-1, 1);
                }
                drawSkeleton({ keypoints: pose.keypoints }, width, height);
                ctx.restore();
            }
        }
        
        // Helper per disegnare connettori Holistic
        function drawHolisticConnectors(landmarks, connections, color, lineWidth, width, height) {
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.lineCap = 'round';
            
            connections.forEach(([i, j]) => {
                const lm1 = landmarks[i];
                const lm2 = landmarks[j];
                if (lm1 && lm2) {
                    ctx.beginPath();
                    ctx.moveTo(lm1.x * width, lm1.y * height);
                    ctx.lineTo(lm2.x * width, lm2.y * height);
                    ctx.stroke();
                }
            });
        }
        
        // Helper per disegnare landmarks Holistic
        function drawHolisticLandmarks(landmarks, color, radius, width, height) {
            ctx.fillStyle = color;
            landmarks.forEach(lm => {
                if (lm && lm.visibility > 0.5) {
                    ctx.beginPath();
                    ctx.arc(lm.x * width, lm.y * height, radius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }
        
        // Converti Holistic pose in formato MoveNet
        function convertHolisticToMoveNet(poseLandmarks, width, height) {
            if (!poseLandmarks || poseLandmarks.length < 33) return null;
            
            // Mapping Holistic -> MoveNet
            const mapping = [0, 2, 5, 7, 8, 11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28];
            
            const keypoints = mapping.map((holisticIdx, moveNetIdx) => {
                const lm = poseLandmarks[holisticIdx];
                return {
                    x: lm.x * width,
                    y: lm.y * height,
                    score: lm.visibility || 0.5,
                    name: Object.keys(KEYPOINTS)[moveNetIdx]
                };
            });
            
            return { keypoints };
        }
        
        // Connessioni per Holistic
        const POSE_CONNECTIONS = [
            [11, 12], [11, 13], [13, 15], [12, 14], [14, 16], // braccia
            [11, 23], [12, 24], [23, 24], // torso
            [23, 25], [25, 27], [24, 26], [26, 28], // gambe
            [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8] // viso
        ];
        
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4], // pollice
            [0, 5], [5, 6], [6, 7], [7, 8], // indice
            [0, 9], [9, 10], [10, 11], [11, 12], // medio
            [0, 13], [13, 14], [14, 15], [15, 16], // anulare
            [0, 17], [17, 18], [18, 19], [19, 20], // mignolo
            [5, 9], [9, 13], [13, 17] // palmo
        ];
        
        // Helper per convertire hex in rgb
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }
        
        // Disegna griglia (solo linee)
        function drawGrid(width, height) {
            const density = state.gridDensity || 16; // default 16x16
            const cellWidth = width / density;
            const cellHeight = height / density;
            
            ctx.save();
            
            // Solo linee, semi-trasparenti
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            
            // Linee verticali
            for (let i = 1; i < density; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellWidth, 0);
                ctx.lineTo(i * cellWidth, height);
                ctx.stroke();
            }
            
            // Linee orizzontali
            for (let j = 1; j < density; j++) {
                ctx.beginPath();
                ctx.moveTo(0, j * cellHeight);
                ctx.lineTo(width, j * cellHeight);
                ctx.stroke();
            }
            
            // Linee centrali pi visibili
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 2;
            
            // Linea centrale verticale
            ctx.beginPath();
            ctx.moveTo(width / 2, 0);
            ctx.lineTo(width / 2, height);
            ctx.stroke();
            
            // Linea centrale orizzontale
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();
            
            ctx.restore();
        }

        function drawFrame(source, pose, forceShowSkeleton = false) {
            const { width, height } = elements.canvas;
            
            ctx.save();
            
            // Handle flip
            if (state.flipVideo) {
                ctx.translate(width, 0);
                ctx.scale(-1, 1);
            }
            
            // Draw video frame
            ctx.drawImage(source, 0, 0, width, height);
            
            ctx.restore();
            
            // Draw grid if enabled
            if (state.showGrid) {
                drawGrid(width, height);
            }
            
            // Draw skeleton overlay
            // Durante playback analizzato, mostra sempre scheletro
            const shouldShowSkeleton = forceShowSkeleton || state.showSkeleton;
            if (shouldShowSkeleton && pose) {
                drawSkeleton(pose, width, height);
            }
        }

        function drawSkeleton(pose, width, height) {
            const isHD = pose.isHD || false;
            
            // Colori per segmento (corrispondono agli allineamenti)
            const segmentColors = {
                shoulders: '#ff6b6b',    // rosso
                hips: '#4ecdc4',         // turchese  
                bowArm: '#ffe66d',       // giallo
                drawArm: '#95e1d3',      // verde acqua
                torso: '#dda0dd',        // viola
                head: '#87ceeb',         // azzurro
                legs: '#ffffff'          // bianco per gambe
            };
            
            ctx.save();
            
            if (state.flipVideo) {
                ctx.translate(width, 0);
                ctx.scale(-1, 1);
            }
            
            ctx.shadowColor = 'rgba(0,0,0,0.6)';
            ctx.shadowBlur = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const keypoints = pose.keypoints;
            const kp = keypoints;
            
            // Determina braccio arco in base alla stance
            const bowSide = state.stance === 'left' ? 'left' : 'right';
            const drawSide = state.stance === 'left' ? 'right' : 'left';
            
            // Funzione per disegnare linea
            const drawLine = (p1, p2, color, lineWidth = 6) => {
                if (p1 && p2 && p1.score > 0.3 && p2.score > 0.3) {
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = lineWidth;
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            };
            
            // Funzione per disegnare punto
            const drawPoint = (p, color, radius = 8) => {
                if (p && p.score > 0.3) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 0;
                    ctx.stroke();
                    ctx.shadowBlur = 4;
                }
            };
            
            // SPALLE (rosso)
            drawLine(kp[KEYPOINTS.leftShoulder], kp[KEYPOINTS.rightShoulder], segmentColors.shoulders, 8);
            drawPoint(kp[KEYPOINTS.leftShoulder], segmentColors.shoulders, 10);
            drawPoint(kp[KEYPOINTS.rightShoulder], segmentColors.shoulders, 10);
            
            // FIANCHI (turchese)
            drawLine(kp[KEYPOINTS.leftHip], kp[KEYPOINTS.rightHip], segmentColors.hips, 8);
            drawPoint(kp[KEYPOINTS.leftHip], segmentColors.hips, 10);
            drawPoint(kp[KEYPOINTS.rightHip], segmentColors.hips, 10);
            
            // BUSTO - connessioni spalle-fianchi (viola)
            drawLine(kp[KEYPOINTS.leftShoulder], kp[KEYPOINTS.leftHip], segmentColors.torso, 6);
            drawLine(kp[KEYPOINTS.rightShoulder], kp[KEYPOINTS.rightHip], segmentColors.torso, 6);
            
            // BRACCIO ARCO (giallo)
            if (bowSide === 'left') {
                drawLine(kp[KEYPOINTS.leftShoulder], kp[KEYPOINTS.leftElbow], segmentColors.bowArm, 6);
                drawLine(kp[KEYPOINTS.leftElbow], kp[KEYPOINTS.leftWrist], segmentColors.bowArm, 6);
                drawPoint(kp[KEYPOINTS.leftElbow], segmentColors.bowArm);
                drawPoint(kp[KEYPOINTS.leftWrist], segmentColors.bowArm);
            } else {
                drawLine(kp[KEYPOINTS.rightShoulder], kp[KEYPOINTS.rightElbow], segmentColors.bowArm, 6);
                drawLine(kp[KEYPOINTS.rightElbow], kp[KEYPOINTS.rightWrist], segmentColors.bowArm, 6);
                drawPoint(kp[KEYPOINTS.rightElbow], segmentColors.bowArm);
                drawPoint(kp[KEYPOINTS.rightWrist], segmentColors.bowArm);
            }
            
            // BRACCIO TRAZIONE (verde acqua)
            if (drawSide === 'left') {
                drawLine(kp[KEYPOINTS.leftShoulder], kp[KEYPOINTS.leftElbow], segmentColors.drawArm, 6);
                drawLine(kp[KEYPOINTS.leftElbow], kp[KEYPOINTS.leftWrist], segmentColors.drawArm, 6);
                drawPoint(kp[KEYPOINTS.leftElbow], segmentColors.drawArm);
                drawPoint(kp[KEYPOINTS.leftWrist], segmentColors.drawArm);
            } else {
                drawLine(kp[KEYPOINTS.rightShoulder], kp[KEYPOINTS.rightElbow], segmentColors.drawArm, 6);
                drawLine(kp[KEYPOINTS.rightElbow], kp[KEYPOINTS.rightWrist], segmentColors.drawArm, 6);
                drawPoint(kp[KEYPOINTS.rightElbow], segmentColors.drawArm);
                drawPoint(kp[KEYPOINTS.rightWrist], segmentColors.drawArm);
            }
            
            // TESTA (azzurro)
            drawLine(kp[KEYPOINTS.nose], kp[KEYPOINTS.leftEye], segmentColors.head, 4);
            drawLine(kp[KEYPOINTS.nose], kp[KEYPOINTS.rightEye], segmentColors.head, 4);
            drawLine(kp[KEYPOINTS.leftEye], kp[KEYPOINTS.leftEar], segmentColors.head, 4);
            drawLine(kp[KEYPOINTS.rightEye], kp[KEYPOINTS.rightEar], segmentColors.head, 4);
            drawPoint(kp[KEYPOINTS.nose], segmentColors.head, 8);
            drawPoint(kp[KEYPOINTS.leftEye], segmentColors.head, 5);
            drawPoint(kp[KEYPOINTS.rightEye], segmentColors.head, 5);
            drawPoint(kp[KEYPOINTS.leftEar], segmentColors.head, 5);
            drawPoint(kp[KEYPOINTS.rightEar], segmentColors.head, 5);
            
            // Linea collo (arancione)
            const midShoulder = {
                x: (kp[KEYPOINTS.leftShoulder].x + kp[KEYPOINTS.rightShoulder].x) / 2,
                y: (kp[KEYPOINTS.leftShoulder].y + kp[KEYPOINTS.rightShoulder].y) / 2,
                score: Math.min(kp[KEYPOINTS.leftShoulder].score, kp[KEYPOINTS.rightShoulder].score)
            };
            drawLine(midShoulder, kp[KEYPOINTS.nose], '#ff9f43', 5);
            
            // GAMBE (bianco)
            drawLine(kp[KEYPOINTS.leftHip], kp[KEYPOINTS.leftKnee], segmentColors.legs, 5);
            drawLine(kp[KEYPOINTS.leftKnee], kp[KEYPOINTS.leftAnkle], segmentColors.legs, 5);
            drawLine(kp[KEYPOINTS.rightHip], kp[KEYPOINTS.rightKnee], segmentColors.legs, 5);
            drawLine(kp[KEYPOINTS.rightKnee], kp[KEYPOINTS.rightAnkle], segmentColors.legs, 5);
            drawPoint(kp[KEYPOINTS.leftKnee], segmentColors.legs, 7);
            drawPoint(kp[KEYPOINTS.leftAnkle], segmentColors.legs, 7);
            drawPoint(kp[KEYPOINTS.rightKnee], segmentColors.legs, 7);
            drawPoint(kp[KEYPOINTS.rightAnkle], segmentColors.legs, 7);
            
            ctx.restore();
        }

        function drawAlignmentLines(keypoints, config) {
            const leftShoulder = keypoints[KEYPOINTS.leftShoulder];
            const rightShoulder = keypoints[KEYPOINTS.rightShoulder];
            const leftHip = keypoints[KEYPOINTS.leftHip];
            const rightHip = keypoints[KEYPOINTS.rightHip];
            
            // Shoulder line
            if (leftShoulder && rightShoulder && leftShoulder.score > 0.3 && rightShoulder.score > 0.3) {
                ctx.setLineDash([10, 5]);
                ctx.strokeStyle = 'rgba(255,255,255,0.7)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(leftShoulder.x - 50, leftShoulder.y);
                ctx.lineTo(rightShoulder.x + 50, rightShoulder.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Hip line
            if (leftHip && rightHip && leftHip.score > 0.3 && rightHip.score > 0.3) {
                ctx.setLineDash([10, 5]);
                ctx.strokeStyle = 'rgba(255,255,255,0.7)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(leftHip.x - 50, leftHip.y);
                ctx.lineTo(rightHip.x + 50, rightHip.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function calculateAngle(p1, p2, p3) {
            const angle = Math.atan2(p3.y - p2.y, p3.x - p2.x) - 
                         Math.atan2(p1.y - p2.y, p1.x - p2.x);
            return Math.abs(angle * 180 / Math.PI);
        }

        function calculateLineAngle(p1, p2) {
            return Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
        }

        function updateAlignments(pose) {
            const kp = pose.keypoints;
            const config = bowConfig[state.bowType];
            const thresholds = config.thresholds;
            
            // Determine bow arm based on stance
            const bowShoulder = state.stance === 'left' ? kp[KEYPOINTS.leftShoulder] : kp[KEYPOINTS.rightShoulder];
            const bowElbow = state.stance === 'left' ? kp[KEYPOINTS.leftElbow] : kp[KEYPOINTS.rightElbow];
            const bowWrist = state.stance === 'left' ? kp[KEYPOINTS.leftWrist] : kp[KEYPOINTS.rightWrist];
            const drawShoulder = state.stance === 'left' ? kp[KEYPOINTS.rightShoulder] : kp[KEYPOINTS.leftShoulder];
            const drawElbow = state.stance === 'left' ? kp[KEYPOINTS.rightElbow] : kp[KEYPOINTS.leftElbow];
            const drawWrist = state.stance === 'left' ? kp[KEYPOINTS.rightWrist] : kp[KEYPOINTS.leftWrist];
            
            // Shoulders alignment
            const shoulderAngle = Math.abs(calculateLineAngle(kp[KEYPOINTS.leftShoulder], kp[KEYPOINTS.rightShoulder]));
            updateAlignmentUI('alignShoulders', shoulderAngle, thresholds.shoulders);
            updateAngleOverlay('angleShoulders', shoulderAngle, thresholds.shoulders, '#ff6b6b');
            
            // Hips alignment
            const hipAngle = Math.abs(calculateLineAngle(kp[KEYPOINTS.leftHip], kp[KEYPOINTS.rightHip]));
            updateAlignmentUI('alignHips', hipAngle, thresholds.hips);
            updateAngleOverlay('angleHips', hipAngle, thresholds.hips, '#4ecdc4');
            
            // Bow arm angle
            if (bowShoulder.score > 0.3 && bowElbow.score > 0.3 && bowWrist.score > 0.3) {
                const bowArmAngle = calculateAngle(bowShoulder, bowElbow, bowWrist);
                const bowArmDiff = Math.abs(bowArmAngle - thresholds.bowArm.target);
                updateAlignmentUI('alignBowArm', bowArmAngle, { good: thresholds.bowArm.good, warning: thresholds.bowArm.warning }, true);
                updateAngleOverlay('angleBowArm', bowArmAngle, { good: thresholds.bowArm.good, warning: thresholds.bowArm.warning }, '#ffe66d', true);
            }
            
            // Draw arm angle
            if (drawShoulder.score > 0.3 && drawElbow.score > 0.3 && drawWrist.score > 0.3) {
                const drawArmAngle = calculateAngle(drawShoulder, drawElbow, drawWrist);
                updateAlignmentUI('alignDrawArm', drawArmAngle, { good: 20, warning: 40 }, true);
                updateAngleOverlay('angleDrawArm', drawArmAngle, { good: 20, warning: 40 }, '#95e1d3', true);
            }
            
            // Torso alignment
            const midShoulder = {
                x: (kp[KEYPOINTS.leftShoulder].x + kp[KEYPOINTS.rightShoulder].x) / 2,
                y: (kp[KEYPOINTS.leftShoulder].y + kp[KEYPOINTS.rightShoulder].y) / 2
            };
            const midHip = {
                x: (kp[KEYPOINTS.leftHip].x + kp[KEYPOINTS.rightHip].x) / 2,
                y: (kp[KEYPOINTS.leftHip].y + kp[KEYPOINTS.rightHip].y) / 2
            };
            const torsoAngle = Math.abs(90 - Math.abs(calculateLineAngle(midHip, midShoulder)));
            updateAlignmentUI('alignTorso', torsoAngle, thresholds.torso);
            updateAngleOverlay('angleTorso', torsoAngle, thresholds.torso, '#dda0dd');
            
            // Head alignment
            const nose = kp[KEYPOINTS.nose];
            if (nose.score > 0.3) {
                const headAngle = Math.abs(calculateLineAngle(midShoulder, nose) + 90);
                updateAlignmentUI('alignHead', headAngle, { good: 5, warning: 10 });
                updateAngleOverlay('angleHead', headAngle, { good: 5, warning: 10 }, '#87ceeb');
            }
        }

        function updateAlignmentUI(elementId, value, thresholds, isAbsolute = false) {
            const element = document.getElementById(elementId);
            if (!element) return;
            const valueSpan = element.querySelector('.alignment-value');
            
            let status = 'bad';
            let compareValue = isAbsolute ? Math.abs(value - 180) : value;
            
            if (compareValue <= thresholds.good) {
                status = 'good';
            } else if (compareValue <= thresholds.warning) {
                status = 'warning';
            }
            
            element.className = `alignment-item ${status}`;
            valueSpan.textContent = `${Math.round(value)}`;
        }
        
        function updateAngleOverlay(elementId, value, thresholds, baseColor, isAbsolute = false) {
            const element = document.getElementById(elementId);
            if (!element) return;
            const valueSpan = element.querySelector('.angle-value');
            
            let status = 'bad';
            let compareValue = isAbsolute ? Math.abs(value - 180) : value;
            
            if (compareValue <= thresholds.good) {
                status = 'good';
            } else if (compareValue <= thresholds.warning) {
                status = 'warning';
            }
            
            element.className = `angle-item ${status}`;
            element.style.setProperty('--angle-color', status === 'good' ? '#22c55e' : status === 'warning' ? '#eab308' : '#ef4444');
            element.style.borderLeftColor = baseColor;
            valueSpan.style.color = status === 'good' ? '#22c55e' : status === 'warning' ? '#eab308' : '#ef4444';
            valueSpan.textContent = `${Math.round(value)}`;
        }

        function updateFps() {
            state.frameCount++;
            const now = Date.now();
            const elapsed = now - state.lastFpsTime;
            
            if (elapsed >= 1000) {
                state.fps = Math.round(state.frameCount * 1000 / elapsed);
                elements.fpsCounter.textContent = `${state.fps} FPS`;
                state.frameCount = 0;
                state.lastFpsTime = now;
            }
        }

        // Recording functionality
        let mediaRecorder;
        let recordedChunks = [];
        let recordingHasSkeleton = false; // Flag per sapere se la registrazione ha lo scheletro
        let recordingStartTime = 0; // Tempo inizio registrazione

        function startRecording() {
            recordedChunks = [];
            recordingStartTime = Date.now(); // Salva tempo inizio
            
            // Registra lo scheletro se  attivo al momento della registrazione
            recordingHasSkeleton = state.showSkeleton;
            
            // Cattura lo stream dal canvas (include tutto: scheletro, griglia, overlay)
            const canvasStream = elements.canvas.captureStream(30); // 30 fps
            
            const options = { mimeType: 'video/webm;codecs=vp9' };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options.mimeType = 'video/webm';
            }
            
            mediaRecorder = new MediaRecorder(canvasStream, options);
            
            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    recordedChunks.push(e.data);
                }
            };
            
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const duration = Math.round((Date.now() - recordingStartTime) / 1000); // durata in secondi
                saveRecording(blob, recordingHasSkeleton, duration);
            };
            
            mediaRecorder.start(100);
            state.isRecording = true;
            
            elements.recordBtn.classList.add('recording');
            elements.modeIndicator.classList.add('recording');
            elements.modeText.textContent = 'REC';
        }

        function stopRecording() {
            if (mediaRecorder && state.isRecording) {
                mediaRecorder.stop();
                state.isRecording = false;
                
                elements.recordBtn.classList.remove('recording');
                elements.modeIndicator.classList.remove('recording');
                elements.modeText.textContent = 'Live';
            }
        }

        function saveRecording(blob, hasSkeleton, duration) {
            const athleteName = currentAthlete ? currentAthlete.name : 'Atleta';
            const timestamp = new Date().toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
            const bowType = state.bowType.charAt(0).toUpperCase() + state.bowType.slice(1);
            
            // Formatta durata (mm:ss)
            const mins = Math.floor(duration / 60);
            const secs = duration % 60;
            const durationStr = `${mins}:${secs.toString().padStart(2, '0')}`;
            
            const recording = {
                id: Date.now(),
                name: `${athleteName} - ${bowType}`,
                time: timestamp,
                duration: durationStr,
                comment: '', // Commento vuoto inizialmente
                blob: blob,
                url: URL.createObjectURL(blob),
                hasSkeleton: hasSkeleton, // Salva se ha lo scheletro
                analyzed: false, // Mai analizzato all'inizio
                frameData: null, // Per salvare i dati dell'analisi frame per frame
                elaborations: [] // Array di elaborazioni (sottoprodotti)
            };
            
            state.recordings.unshift(recording);
            updateRecordingsList();
        }
        
        // Crea una nuova elaborazione come sottoprodotto
        function createElaboration(parentRecording, model, frameData, settings) {
            const modelLabels = { holistic: 'H', lightning: 'L', bodypix: 'B' };
            const timestamp = new Date().toLocaleTimeString('it-IT', { hour: '2-digit', minute: '2-digit' });
            
            // Assicurati che elaborations esista
            if (!parentRecording.elaborations) {
                parentRecording.elaborations = [];
            }
            
            const elaboration = {
                id: Date.now(),
                model: model,
                modelLabel: modelLabels[model] || '?',
                time: timestamp,
                frameData: frameData,
                settings: {
                    showGrid: settings.showGrid,
                    gridDensity: settings.gridDensity,
                    showAlignments: settings.showAlignments
                }
            };
            
            parentRecording.elaborations.push(elaboration);
            updateRecordingsList();
            return elaboration;
        }

        function updateRecordingsList() {
            if (state.recordings.length === 0) {
                elements.recordingsList.innerHTML = `
                    <div class="empty-state">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M3 6a2 2 0 012-2h8a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V6z"/>
                        </svg>
                        <p>Nessuna registrazione</p>
                    </div>
                `;
                return;
            }
            
            // Genera HTML per ogni registrazione con le sue elaborazioni
            const generateRecordingHTML = (rec) => {
                // Genera HTML per le elaborazioni (sottoprodotti)
                const elaborationsHTML = (rec.elaborations || []).map(elab => {
                    const gridIcon = elab.settings?.showGrid ? '' : '';
                    const infoIcon = elab.settings?.showAlignments ? '' : '';
                    return `
                        <div class="elaboration-item" data-rec-id="${rec.id}" data-elab-id="${elab.id}">
                            <span class="elaboration-badge model-${elab.model}">${elab.modelLabel}</span>
                            <span class="elaboration-icons">${gridIcon}${infoIcon}</span>
                            <span class="elaboration-time">${elab.time}</span>
                            <button class="elaboration-download" data-rec-id="${rec.id}" data-elab-id="${elab.id}" title="Scarica elaborazione">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/>
                                </svg>
                            </button>
                        </div>
                    `;
                }).join('');
                
                return `
                    <div class="recording-group">
                        <div class="recording-item" data-id="${rec.id}">
                            <div class="recording-info">
                                <span class="recording-name">${rec.name}</span>
                                <span class="recording-meta">${rec.time}  ${rec.duration || '0:00'}</span>
                                <input type="text" class="recording-comment" data-id="${rec.id}" 
                                       placeholder="Aggiungi nota..." 
                                       value="${rec.comment || ''}" 
                                       onclick="event.stopPropagation()">
                            </div>
                            <div class="recording-actions">
                                <button class="recording-download" data-id="${rec.id}" title="Scarica">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/>
                                    </svg>
                                </button>
                                <button class="recording-delete" data-id="${rec.id}" title="Elimina">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6M8 6V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        ${elaborationsHTML ? `<div class="elaborations-list">${elaborationsHTML}</div>` : ''}
                    </div>
                `;
            };
            
            elements.recordingsList.innerHTML = state.recordings.map(generateRecordingHTML).join('');
            
            // Add click listeners per visualizzare registrazione originale
            elements.recordingsList.querySelectorAll('.recording-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.recording-delete') && !e.target.closest('.recording-download') && !e.target.closest('.recording-comment')) {
                        const id = parseInt(item.dataset.id);
                        playRecording(id);
                    }
                });
            });
            
            // Add click listeners per visualizzare elaborazione
            elements.recordingsList.querySelectorAll('.elaboration-item').forEach(item => {
                item.addEventListener('click', () => {
                    const recId = parseInt(item.dataset.recId);
                    const elabId = parseInt(item.dataset.elabId);
                    playElaboration(recId, elabId);
                });
            });
            
            // Add listeners per commenti
            elements.recordingsList.querySelectorAll('.recording-comment').forEach(input => {
                input.addEventListener('change', (e) => {
                    const id = parseInt(input.dataset.id);
                    const rec = state.recordings.find(r => r.id === id);
                    if (rec) {
                        rec.comment = input.value;
                    }
                });
            });
            
            // Add click listeners per download
            elements.recordingsList.querySelectorAll('.recording-download').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const id = parseInt(btn.dataset.id);
                    downloadRecording(id);
                });
            });
            
            // Add click listeners per download elaborazioni
            elements.recordingsList.querySelectorAll('.elaboration-download').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const recId = parseInt(btn.dataset.recId);
                    const elabId = parseInt(btn.dataset.elabId);
                    downloadElaboration(recId, elabId);
                });
            });
            
            // Add click listeners per eliminare
            elements.recordingsList.querySelectorAll('.recording-delete').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const id = parseInt(btn.dataset.id);
                    deleteRecording(id);
                });
            });
        }
        
        // Riproduce un'elaborazione specifica
        function playElaboration(recId, elabId) {
            const recording = state.recordings.find(r => r.id === recId);
            if (!recording) return;
            
            const elaboration = (recording.elaborations || []).find(e => e.id === elabId);
            if (!elaboration) return;
            
            // Imposta il video
            elements.playbackVideo.src = recording.url;
            state.isPlayback = true;
            state.currentRecording = recording;
            state.currentFrame = 0;
            
            // Carica i dati dell'elaborazione
            state.analyzedFrames = elaboration.frameData;
            state.currentElaboration = elaboration;
            
            // Applica le impostazioni salvate
            if (elaboration.settings) {
                state.showGrid = elaboration.settings.showGrid;
                state.gridDensity = elaboration.settings.gridDensity;
                state.showAlignments = elaboration.settings.showAlignments;
                
                // Aggiorna UI
                document.getElementById('gridDensitySelect').value = elaboration.settings.gridDensity;
                document.getElementById('anglesOverlay').style.display = elaboration.settings.showAlignments ? 'flex' : 'none';
            }
            
            elements.video.style.display = 'none';
            elements.playbackVideo.style.display = 'block';
            elements.liveControls.style.display = 'none';
            elements.playbackControls.classList.add('active');
            
            // Mostra controlli playback nel menu fullscreen
            document.getElementById('fsPlaybackSection').style.display = 'block';
            document.getElementById('fsPlayPauseBtn').textContent = ' Play';
            
            elements.modeIndicator.classList.add('playback');
            elements.playbackVideo.playbackRate = state.playbackSpeed;
            elements.modeText.textContent = `Elab. ${elaboration.modelLabel}`;
            
            // Nascondi pulsante AI (gi elaborato)
            const analyzeBtn = document.getElementById('analyzeBtn');
            analyzeBtn.classList.remove('analyzing', 'done');
            analyzeBtn.querySelector('.analyze-text').textContent = elaboration.modelLabel;
            analyzeBtn.classList.add('done');
            
            elements.playbackVideo.onloadedmetadata = () => {
                elements.canvas.width = elements.playbackVideo.videoWidth;
                elements.canvas.height = elements.playbackVideo.videoHeight;
                updatePlaybackUI();
                detectPlaybackPose();
            };
            
            elements.playbackVideo.ontimeupdate = updatePlaybackUI;
        }
        
        function downloadRecording(id) {
            const recording = state.recordings.find(r => r.id === id);
            if (!recording) return;
            
            const link = document.createElement('a');
            const filename = `${recording.name.replace(/[^a-z0-9]/gi, '_')}_${recording.id}.webm`;
            link.href = recording.url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Download elaborazione con scheletro/griglia renderizzati nel video
        async function downloadElaboration(recId, elabId) {
            const recording = state.recordings.find(r => r.id === recId);
            if (!recording) return;
            
            const elaboration = (recording.elaborations || []).find(e => e.id === elabId);
            if (!elaboration) return;
            
            const model = elaboration.model; // holistic, lightning, bodypix
            
            // Mostra progresso dettagliato
            const statusEl = document.createElement('div');
            statusEl.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--bg-secondary);padding:2rem 3rem;border-radius:16px;z-index:9999;text-align:center;box-shadow:0 8px 32px rgba(0,0,0,0.5);min-width:350px;';
            statusEl.innerHTML = `
                <p style="margin-bottom:0.5rem;font-weight:bold;font-size:1.1rem;">Generazione Video con AI</p>
                <p style="margin-bottom:0.5rem;color:var(--text-muted);font-size:0.85rem;">Modello: ${model.toUpperCase()}</p>
                <p id="exportPhase" style="margin-bottom:0.5rem;color:var(--accent-current);font-size:0.8rem;font-weight:bold;">FASE 1/3: Estrazione frame</p>
                <div style="background:var(--bg-tertiary);border-radius:8px;height:24px;overflow:hidden;margin-bottom:1rem;">
                    <div id="exportProgressBar" style="background:var(--accent-current);height:100%;width:0%;transition:width 0.2s;"></div>
                </div>
                <p id="exportStatus" style="font-size:0.9rem;">Preparazione...</p>
                <p id="exportDetails" style="font-size:0.8rem;color:var(--text-muted);margin-top:0.5rem;"></p>
                <button id="exportCancel" style="margin-top:1rem;padding:0.5rem 1.5rem;background:var(--danger);border:none;color:white;border-radius:8px;cursor:pointer;">Annulla</button>
            `;
            document.body.appendChild(statusEl);
            
            let cancelled = false;
            document.getElementById('exportCancel').addEventListener('click', () => {
                cancelled = true;
            });
            
            const updateProgress = (phase, phaseNum, percent, status, details = '') => {
                document.getElementById('exportPhase').textContent = `FASE ${phaseNum}/3: ${phase}`;
                document.getElementById('exportProgressBar').style.width = `${percent}%`;
                document.getElementById('exportStatus').textContent = status;
                document.getElementById('exportDetails').textContent = details;
            };
            
            let exportDetector = null;
            let exportHolistic = null;
            let exportBodyPix = null;
            
            try {
                // ============================================
                // FASE 0: Preparazione e caricamento modello AI
                // ============================================
                updateProgress('Caricamento AI', 0, 0, 'Inizializzazione modello...', 'Configurazione alta qualit');
                
                if (model === 'holistic') {
                    exportHolistic = new Holistic({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic@0.5.1675471629/${file}`
                    });
                    exportHolistic.setOptions({
                        modelComplexity: 2,        // MASSIMA qualit
                        smoothLandmarks: false,    // No smoothing per massima precisione
                        enableSegmentation: false,
                        refineFaceLandmarks: true, // Dettagli viso
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });
                    await exportHolistic.initialize();
                    
                } else if (model === 'bodypix') {
                    exportBodyPix = await bodyPix.load({
                        architecture: 'ResNet50',
                        outputStride: 16,
                        quantBytes: 4
                    });
                    
                } else {
                    // Lightning  Thunder per massima qualit
                    exportDetector = await poseDetection.createDetector(
                        poseDetection.SupportedModels.MoveNet,
                        { 
                            modelType: poseDetection.movenet.modelType.SINGLEPOSE_THUNDER,
                            enableSmoothing: false
                        }
                    );
                }
                
                // Prepara video sorgente
                const tempVideo = document.createElement('video');
                tempVideo.src = recording.url;
                tempVideo.muted = true;
                tempVideo.playsInline = true;
                tempVideo.preload = 'auto';
                
                await new Promise((resolve, reject) => {
                    tempVideo.onloadedmetadata = resolve;
                    tempVideo.onerror = reject;
                });
                
                // Aspetta che il video sia completamente caricato
                await new Promise((resolve) => {
                    if (tempVideo.readyState >= 3) {
                        resolve();
                    } else {
                        tempVideo.oncanplaythrough = resolve;
                    }
                });
                
                const width = tempVideo.videoWidth;
                const height = tempVideo.videoHeight;
                const duration = tempVideo.duration;
                const fps = 30;
                const totalFrames = Math.floor(duration * fps);
                
                // Stima tempo totale
                const msPerFrame = model === 'holistic' ? 200 : (model === 'bodypix' ? 120 : 60);
                const estimatedSeconds = Math.round((totalFrames * msPerFrame * 2) / 1000); // x2 per estrazione + analisi
                const estimatedMin = Math.floor(estimatedSeconds / 60);
                const estimatedSec = estimatedSeconds % 60;
                
                updateProgress('Caricamento AI', 0, 5, 'Modello pronto', `${totalFrames} frame  Stimato: ~${estimatedMin}m ${estimatedSec}s`);
                
                // Canvas per estrazione e rendering
                const extractCanvas = document.createElement('canvas');
                extractCanvas.width = width;
                extractCanvas.height = height;
                const extractCtx = extractCanvas.getContext('2d');
                
                // ============================================
                // FASE 1: Estrazione frame dal video
                // ============================================
                const extractedFrames = []; // Array di ImageData
                const startPhase1 = Date.now();
                
                for (let frameNum = 0; frameNum < totalFrames; frameNum++) {
                    if (cancelled) throw new Error('Annullato dall\'utente');
                    
                    const targetTime = frameNum / fps;
                    tempVideo.currentTime = targetTime;
                    
                    // Aspetta seek completato
                    await new Promise(resolve => {
                        const onSeeked = () => {
                            tempVideo.removeEventListener('seeked', onSeeked);
                            resolve();
                        };
                        tempVideo.addEventListener('seeked', onSeeked);
                        // Timeout di sicurezza
                        setTimeout(resolve, 500);
                    });
                    
                    // Piccola pausa per stabilizzare il frame
                    await new Promise(r => setTimeout(r, 10));
                    
                    // Estrai frame come ImageData
                    extractCtx.save();
                    if (state.flipVideo) {
                        extractCtx.translate(width, 0);
                        extractCtx.scale(-1, 1);
                    }
                    extractCtx.drawImage(tempVideo, 0, 0, width, height);
                    extractCtx.restore();
                    
                    const imageData = extractCtx.getImageData(0, 0, width, height);
                    extractedFrames.push(imageData);
                    
                    // Aggiorna progresso Fase 1 (0-33%)
                    const progress1 = Math.round(((frameNum + 1) / totalFrames) * 100);
                    const elapsed1 = (Date.now() - startPhase1) / 1000;
                    const remaining1 = Math.round((elapsed1 / (frameNum + 1)) * (totalFrames - frameNum - 1));
                    
                    updateProgress('Estrazione frame', 1, Math.round(progress1 * 0.33), 
                        `Frame ${frameNum + 1}/${totalFrames}`,
                        `${progress1}%  Rimanente fase: ${Math.floor(remaining1/60)}m ${remaining1%60}s`
                    );
                    
                    // Yield per UI
                    if (frameNum % 10 === 0) {
                        await new Promise(r => setTimeout(r, 1));
                    }
                }
                
                console.log(`Fase 1 completata: ${extractedFrames.length} frame estratti`);
                
                // ============================================
                // FASE 2: Analisi AI di ogni frame
                // ============================================
                const analyzedFrames = []; // Array di {imageData, holisticData/keypoints}
                const startPhase2 = Date.now();
                
                // Canvas per analisi (l'AI lavora su canvas, non su ImageData direttamente)
                const analysisCanvas = document.createElement('canvas');
                analysisCanvas.width = width;
                analysisCanvas.height = height;
                const analysisCtx = analysisCanvas.getContext('2d');
                
                for (let frameNum = 0; frameNum < extractedFrames.length; frameNum++) {
                    if (cancelled) throw new Error('Annullato dall\'utente');
                    
                    // Metti ImageData sul canvas per analisi
                    analysisCtx.putImageData(extractedFrames[frameNum], 0, 0);
                    
                    let analysisResult = {
                        imageData: extractedFrames[frameNum],
                        holisticData: null,
                        keypoints: null
                    };
                    
                    // Analizza con AI
                    if (model === 'holistic' && exportHolistic) {
                        const holisticResult = await new Promise((resolve) => {
                            exportHolistic.onResults((results) => resolve(results));
                            exportHolistic.send({ image: analysisCanvas });
                        });
                        
                        if (holisticResult && holisticResult.poseLandmarks) {
                            analysisResult.holisticData = {
                                poseLandmarks: holisticResult.poseLandmarks,
                                leftHandLandmarks: holisticResult.leftHandLandmarks,
                                rightHandLandmarks: holisticResult.rightHandLandmarks,
                                faceLandmarks: holisticResult.faceLandmarks
                            };
                        }
                        
                    } else if (model === 'bodypix' && exportBodyPix) {
                        const segmentation = await exportBodyPix.segmentPerson(analysisCanvas, {
                            flipHorizontal: false,
                            internalResolution: 'high',
                            segmentationThreshold: 0.7
                        });
                        
                        if (segmentation && segmentation.allPoses && segmentation.allPoses.length > 0) {
                            analysisResult.keypoints = segmentation.allPoses[0].keypoints;
                        }
                        
                    } else if (exportDetector) {
                        const poses = await exportDetector.estimatePoses(analysisCanvas);
                        if (poses.length > 0) {
                            analysisResult.keypoints = poses[0].keypoints;
                        }
                    }
                    
                    analyzedFrames.push(analysisResult);
                    
                    // Aggiorna progresso Fase 2 (33-66%)
                    const progress2 = Math.round(((frameNum + 1) / extractedFrames.length) * 100);
                    const elapsed2 = (Date.now() - startPhase2) / 1000;
                    const remaining2 = Math.round((elapsed2 / (frameNum + 1)) * (extractedFrames.length - frameNum - 1));
                    
                    updateProgress('Analisi AI', 2, 33 + Math.round(progress2 * 0.33),
                        `Frame ${frameNum + 1}/${extractedFrames.length}`,
                        `${progress2}%  Rimanente fase: ${Math.floor(remaining2/60)}m ${remaining2%60}s`
                    );
                    
                    // Yield per UI
                    if (frameNum % 3 === 0) {
                        await new Promise(r => setTimeout(r, 1));
                    }
                }
                
                console.log(`Fase 2 completata: ${analyzedFrames.length} frame analizzati`);
                
                // Libera memoria dei frame estratti (non servono pi)
                extractedFrames.length = 0;
                
                // ============================================
                // FASE 3: Composizione video finale
                // ============================================
                updateProgress('Composizione video', 3, 66, 'Preparazione encoder...', '');
                
                const renderCanvas = document.createElement('canvas');
                renderCanvas.width = width;
                renderCanvas.height = height;
                const renderCtx = renderCanvas.getContext('2d');
                
                // Setup MediaRecorder
                const stream = renderCanvas.captureStream(fps);
                const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') 
                    ? 'video/webm;codecs=vp9' : 'video/webm';
                const mediaRecorder = new MediaRecorder(stream, { 
                    mimeType: mimeType,
                    videoBitsPerSecond: 8000000
                });
                
                const chunks = [];
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) chunks.push(e.data);
                };
                
                // Funzione per aggiungere un frame al video
                const addFrameToVideo = (frameData) => {
                    return new Promise(resolve => {
                        // Disegna frame originale
                        renderCtx.putImageData(frameData.imageData, 0, 0);
                        
                        // Disegna scheletro
                        if (frameData.holisticData) {
                            renderHolisticOnCanvas(renderCtx, frameData.holisticData, width, height);
                        } else if (frameData.keypoints) {
                            renderSkeletonOnCanvas(renderCtx, frameData.keypoints, width, height);
                        }
                        
                        // Disegna griglia se attiva
                        if (elaboration.settings?.showGrid) {
                            const density = elaboration.settings.gridDensity || 16;
                            renderGridOnCanvas(renderCtx, width, height, density);
                        }
                        
                        // Aspetta un frame time per la registrazione
                        setTimeout(resolve, 1000 / fps);
                    });
                };
                
                mediaRecorder.start(100);
                const startPhase3 = Date.now();
                
                for (let frameNum = 0; frameNum < analyzedFrames.length; frameNum++) {
                    if (cancelled) {
                        mediaRecorder.stop();
                        throw new Error('Annullato dall\'utente');
                    }
                    
                    await addFrameToVideo(analyzedFrames[frameNum]);
                    
                    // Aggiorna progresso Fase 3 (66-100%)
                    const progress3 = Math.round(((frameNum + 1) / analyzedFrames.length) * 100);
                    const elapsed3 = (Date.now() - startPhase3) / 1000;
                    const remaining3 = Math.round((elapsed3 / (frameNum + 1)) * (analyzedFrames.length - frameNum - 1));
                    
                    updateProgress('Composizione video', 3, 66 + Math.round(progress3 * 0.32),
                        `Frame ${frameNum + 1}/${analyzedFrames.length}`,
                        `${progress3}%  Rimanente: ${Math.floor(remaining3/60)}m ${remaining3%60}s`
                    );
                    
                    // Yield per UI ogni 10 frame
                    if (frameNum % 10 === 0) {
                        await new Promise(r => setTimeout(r, 1));
                    }
                }
                
                // Ferma recording
                mediaRecorder.stop();
                
                await new Promise(resolve => {
                    mediaRecorder.onstop = resolve;
                });
                
                updateProgress('Composizione video', 3, 99, 'Preparazione download...', '');
                
                // Crea blob e scarica
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                const filename = `${recording.name.replace(/[^a-z0-9]/gi, '_')}_${elaboration.modelLabel}_HQ.webm`;
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                
                // Libera memoria
                analyzedFrames.length = 0;
                
                updateProgress('Completato!', 3, 100, 'Download avviato!', '');
                await new Promise(r => setTimeout(r, 1500));
                
            } catch (error) {
                console.error('Errore export elaborazione:', error);
                if (!cancelled) {
                    alert('Errore durante la generazione del video: ' + error.message);
                }
            } finally {
                // Cleanup detector
                try {
                    if (exportDetector) exportDetector.dispose();
                    if (exportHolistic) exportHolistic.close();
                } catch(e) {}
                
                document.body.removeChild(statusEl);
            }
        }
        
        // Renderizza griglia su canvas
        function renderGridOnCanvas(ctx, width, height, density) {
            const cellWidth = width / density;
            const cellHeight = height / density;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            
            for (let i = 1; i < density; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellWidth, 0);
                ctx.lineTo(i * cellWidth, height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * cellHeight);
                ctx.lineTo(width, i * cellHeight);
                ctx.stroke();
            }
        }
        
        // Renderizza scheletro standard su canvas
        function renderSkeletonOnCanvas(ctx, keypoints, width, height) {
            if (!keypoints || keypoints.length < 17) return;
            
            ctx.save();
            if (state.flipVideo) {
                ctx.translate(width, 0);
                ctx.scale(-1, 1);
            }
            
            const config = bowConfig[state.bowType];
            ctx.strokeStyle = config.color;
            ctx.fillStyle = config.color;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            
            // Connessioni scheletro
            const connections = [
                [5, 6], [5, 7], [7, 9], [6, 8], [8, 10],
                [5, 11], [6, 12], [11, 12],
                [11, 13], [13, 15], [12, 14], [14, 16]
            ];
            
            connections.forEach(([i, j]) => {
                const kp1 = keypoints[i];
                const kp2 = keypoints[j];
                if (kp1 && kp2 && kp1.score > 0.3 && kp2.score > 0.3) {
                    ctx.beginPath();
                    ctx.moveTo(kp1.x, kp1.y);
                    ctx.lineTo(kp2.x, kp2.y);
                    ctx.stroke();
                }
            });
            
            // Punti
            keypoints.forEach(kp => {
                if (kp && kp.score > 0.3) {
                    ctx.beginPath();
                    ctx.arc(kp.x, kp.y, 6, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
            
            ctx.restore();
        }
        
        // Renderizza Holistic completo su canvas
        function renderHolisticOnCanvas(ctx, holisticData, width, height) {
            if (!holisticData || !holisticData.poseLandmarks) return;
            
            ctx.save();
            if (state.flipVideo) {
                ctx.translate(width, 0);
                ctx.scale(-1, 1);
            }
            
            ctx.shadowColor = 'rgba(0,0,0,0.6)';
            ctx.shadowBlur = 4;
            ctx.lineCap = 'round';
            
            const lm = holisticData.poseLandmarks;
            const bowSide = state.stance === 'left' ? 'left' : 'right';
            
            const segmentColors = {
                shoulders: '#ff6b6b',
                hips: '#4ecdc4',
                bowArm: '#ffe66d',
                drawArm: '#95e1d3',
                torso: '#dda0dd',
                head: '#87ceeb',
                neck: '#ff9f43',
                legs: '#ffffff'
            };
            
            const drawLine = (idx1, idx2, color, lineWidth = 6) => {
                if (lm[idx1] && lm[idx2]) {
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = lineWidth;
                    ctx.moveTo(lm[idx1].x * width, lm[idx1].y * height);
                    ctx.lineTo(lm[idx2].x * width, lm[idx2].y * height);
                    ctx.stroke();
                }
            };
            
            const drawPoint = (idx, color, radius = 8) => {
                if (lm[idx]) {
                    ctx.beginPath();
                    ctx.arc(lm[idx].x * width, lm[idx].y * height, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 0;
                    ctx.stroke();
                    ctx.shadowBlur = 4;
                }
            };
            
            // Corpo
            drawLine(11, 12, segmentColors.shoulders, 8);
            drawPoint(11, segmentColors.shoulders, 10);
            drawPoint(12, segmentColors.shoulders, 10);
            
            drawLine(23, 24, segmentColors.hips, 8);
            drawPoint(23, segmentColors.hips, 10);
            drawPoint(24, segmentColors.hips, 10);
            
            drawLine(11, 23, segmentColors.torso, 6);
            drawLine(12, 24, segmentColors.torso, 6);
            
            if (bowSide === 'left') {
                drawLine(11, 13, segmentColors.bowArm, 6);
                drawLine(13, 15, segmentColors.bowArm, 6);
                drawPoint(13, segmentColors.bowArm);
                drawPoint(15, segmentColors.bowArm);
                drawLine(12, 14, segmentColors.drawArm, 6);
                drawLine(14, 16, segmentColors.drawArm, 6);
                drawPoint(14, segmentColors.drawArm);
                drawPoint(16, segmentColors.drawArm);
            } else {
                drawLine(12, 14, segmentColors.bowArm, 6);
                drawLine(14, 16, segmentColors.bowArm, 6);
                drawPoint(14, segmentColors.bowArm);
                drawPoint(16, segmentColors.bowArm);
                drawLine(11, 13, segmentColors.drawArm, 6);
                drawLine(13, 15, segmentColors.drawArm, 6);
                drawPoint(13, segmentColors.drawArm);
                drawPoint(15, segmentColors.drawArm);
            }
            
            // Collo
            if (lm[11] && lm[12] && lm[0]) {
                const midX = (lm[11].x + lm[12].x) / 2 * width;
                const midY = (lm[11].y + lm[12].y) / 2 * height;
                ctx.beginPath();
                ctx.strokeStyle = segmentColors.neck;
                ctx.lineWidth = 5;
                ctx.moveTo(midX, midY);
                ctx.lineTo(lm[0].x * width, lm[0].y * height);
                ctx.stroke();
            }
            
            drawPoint(0, segmentColors.head, 8);
            
            // Gambe
            drawLine(23, 25, segmentColors.legs, 5);
            drawLine(25, 27, segmentColors.legs, 5);
            drawLine(24, 26, segmentColors.legs, 5);
            drawLine(26, 28, segmentColors.legs, 5);
            drawPoint(25, segmentColors.legs, 6);
            drawPoint(27, segmentColors.legs, 6);
            drawPoint(26, segmentColors.legs, 6);
            drawPoint(28, segmentColors.legs, 6);
            
            // Mani
            const handColor = '#ffcc00';
            const handConnections = [
                [0,1],[1,2],[2,3],[3,4],
                [0,5],[5,6],[6,7],[7,8],
                [0,9],[9,10],[10,11],[11,12],
                [0,13],[13,14],[14,15],[15,16],
                [0,17],[17,18],[18,19],[19,20],
                [5,9],[9,13],[13,17]
            ];
            
            const drawHand = (landmarks) => {
                if (!landmarks || landmarks.length === 0) return;
                ctx.strokeStyle = handColor;
                ctx.lineWidth = 3;
                handConnections.forEach(([i, j]) => {
                    if (landmarks[i] && landmarks[j]) {
                        ctx.beginPath();
                        ctx.moveTo(landmarks[i].x * width, landmarks[i].y * height);
                        ctx.lineTo(landmarks[j].x * width, landmarks[j].y * height);
                        ctx.stroke();
                    }
                });
                ctx.fillStyle = handColor;
                landmarks.forEach(pt => {
                    if (pt) {
                        ctx.beginPath();
                        ctx.arc(pt.x * width, pt.y * height, 4, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                });
            };
            
            drawHand(holisticData.leftHandLandmarks);
            drawHand(holisticData.rightHandLandmarks);
            
            // Viso
            if (holisticData.faceLandmarks && holisticData.faceLandmarks.length > 0) {
                const faceContour = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109, 10];
                ctx.beginPath();
                ctx.strokeStyle = '#87ceeb';
                ctx.lineWidth = 2;
                faceContour.forEach((idx, i) => {
                    if (holisticData.faceLandmarks[idx]) {
                        const pt = holisticData.faceLandmarks[idx];
                        if (i === 0) ctx.moveTo(pt.x * width, pt.y * height);
                        else ctx.lineTo(pt.x * width, pt.y * height);
                    }
                });
                ctx.closePath();
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function playRecording(id) {
            const recording = state.recordings.find(r => r.id === id);
            if (!recording) return;
            
            state.currentRecording = recording;
            state.isPlayback = true;
            state.currentFrame = 0;
            state.currentElaboration = null; // Reset elaborazione corrente
            state.analyzedFrames = {}; // Reset frame analizzati (visualizza originale)
            
            elements.video.style.display = 'none';
            elements.playbackVideo.style.display = 'block';
            elements.playbackVideo.src = recording.url;
            elements.playbackVideo.playbackRate = state.playbackSpeed;
            
            elements.liveControls.style.display = 'none';
            elements.playbackControls.classList.add('active');
            
            // Mostra controlli playback nel menu fullscreen
            document.getElementById('fsPlaybackSection').style.display = 'block';
            document.getElementById('fsPlayPauseBtn').textContent = ' Play';
            
            elements.modeIndicator.classList.add('playback');
            elements.modeText.textContent = 'Originale';
            
            // Mostra sempre il pulsante Analizza (ora crea sottoprodotti)
            const analyzeBtn = document.getElementById('analyzeBtn');
            analyzeBtn.style.display = 'flex';
            analyzeBtn.classList.remove('analyzing', 'done');
            analyzeBtn.querySelector('.analyze-text').textContent = 'AI';
            
            elements.playbackVideo.onloadedmetadata = () => {
                elements.canvas.width = elements.playbackVideo.videoWidth;
                elements.canvas.height = elements.playbackVideo.videoHeight;
                updatePlaybackUI();
            };
            
            elements.playbackVideo.ontimeupdate = updatePlaybackUI;
            
            // Start playback rendering
            if (recording.hasSkeleton) {
                // Video gi con scheletro integrato, mostra direttamente
                renderPlaybackWithSkeleton();
            } else {
                // Video senza scheletro
                detectPlaybackPose();
            }
        }
        
        // Renderizza playback per video che hanno gi lo scheletro
        function renderPlaybackWithSkeleton() {
            if (!state.isPlayback) return;
            
            const { width, height } = elements.canvas;
            ctx.drawImage(elements.playbackVideo, 0, 0, width, height);
            
            if (state.isPlayback) {
                requestAnimationFrame(renderPlaybackWithSkeleton);
            }
        }

        async function detectPlaybackPose() {
            if (!state.isPlayback) return;
            
            const recording = state.currentRecording;
            
            // Se il video ha gi lo scheletro, non serve detection
            if (recording && recording.hasSkeleton) {
                renderPlaybackWithSkeleton();
                return;
            }
            
            if (elements.playbackVideo.readyState >= 2) {
                const currentTime = elements.playbackVideo.currentTime;
                const frameNum = Math.floor(currentTime * 30);
                
                let pose = null;
                let hasAnalyzedData = false;
                let holisticData = null; // Per dati Holistic completi
                
                // Usa frame analizzato se disponibile
                if (state.analyzedFrames && state.analyzedFrames[frameNum]) {
                    pose = { keypoints: state.analyzedFrames[frameNum].keypoints };
                    holisticData = state.analyzedFrames[frameNum].holisticData || null;
                    hasAnalyzedData = true;
                } else if (state.detector && !elements.playbackVideo.paused) {
                    // Solo se il video sta andando, altrimenti usa l'ultima pose
                    try {
                        const poses = await state.detector.estimatePoses(elements.playbackVideo);
                        if (poses.length > 0) {
                            pose = poses[0];
                        }
                    } catch(e) {
                        console.error('Errore detection playback:', e);
                    }
                } else if (state.currentPose) {
                    pose = state.currentPose;
                }
                
                if (pose) {
                    state.currentPose = pose;
                    updateAlignments(pose);
                }
                
                const forceShow = hasAnalyzedData || (recording && recording.analyzed);
                const { width, height } = elements.canvas;
                
                // Disegna video
                ctx.save();
                if (state.flipVideo) {
                    ctx.translate(width, 0);
                    ctx.scale(-1, 1);
                }
                ctx.drawImage(elements.playbackVideo, 0, 0, width, height);
                ctx.restore();
                
                // Disegna griglia se attiva
                if (state.showGrid) {
                    drawGrid(width, height);
                }
                
                // Se ci sono dati Holistic, usa lo stile Holistic completo
                if (holisticData && forceShow) {
                    drawHolisticBodyPlayback(holisticData, width, height);
                    drawHolisticExtras(holisticData, width, height);
                } else if (forceShow && pose) {
                    // Altrimenti usa stile standard MoveNet
                    drawSkeleton(pose, width, height);
                }
            }
            
            if (state.isPlayback) {
                requestAnimationFrame(detectPlaybackPose);
            }
        }
        
        // Disegna mani e faccia da dati Holistic salvati (stesso stile del live)
        function drawHolisticExtras(holisticData, width, height) {
            ctx.save();
            
            if (state.flipVideo) {
                ctx.translate(width, 0);
                ctx.scale(-1, 1);
            }
            
            ctx.shadowColor = 'rgba(0,0,0,0.6)';
            ctx.shadowBlur = 4;
            ctx.lineCap = 'round';
            
            const handColor = '#ffcc00'; // giallo oro come nel live
            
            // Disegna mani con stile live
            if (holisticData.leftHandLandmarks) {
                drawHolisticConnectors(holisticData.leftHandLandmarks, HAND_CONNECTIONS, handColor, 3, width, height);
                drawHolisticLandmarks(holisticData.leftHandLandmarks, handColor, 4, width, height);
            }
            
            if (holisticData.rightHandLandmarks) {
                drawHolisticConnectors(holisticData.rightHandLandmarks, HAND_CONNECTIONS, handColor, 3, width, height);
                drawHolisticLandmarks(holisticData.rightHandLandmarks, handColor, 4, width, height);
            }
            
            // Disegna perimetro testa (azzurro come nel live)
            if (holisticData.faceLandmarks && holisticData.faceLandmarks.length > 0) {
                const faceContour = [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109, 10];
                
                ctx.beginPath();
                ctx.strokeStyle = '#87ceeb'; // azzurro come testa
                ctx.lineWidth = 2;
                
                faceContour.forEach((idx, i) => {
                    if (holisticData.faceLandmarks[idx]) {
                        const lm = holisticData.faceLandmarks[idx];
                        if (i === 0) {
                            ctx.moveTo(lm.x * width, lm.y * height);
                        } else {
                            ctx.lineTo(lm.x * width, lm.y * height);
                        }
                    }
                });
                ctx.closePath();
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        // Disegna corpo Holistic nel playback (stesso stile del live)
        function drawHolisticBodyPlayback(holisticData, width, height) {
            if (!holisticData || !holisticData.poseLandmarks) return;
            
            ctx.save();
            
            if (state.flipVideo) {
                ctx.translate(width, 0);
                ctx.scale(-1, 1);
            }
            
            ctx.shadowColor = 'rgba(0,0,0,0.6)';
            ctx.shadowBlur = 4;
            ctx.lineCap = 'round';
            
            const lm = holisticData.poseLandmarks;
            const bowSide = state.stance === 'left' ? 'left' : 'right';
            
            // Colori per segmento (identici al live)
            const segmentColors = {
                shoulders: '#ff6b6b',    // rosso
                hips: '#4ecdc4',         // turchese  
                bowArm: '#ffe66d',       // giallo
                drawArm: '#95e1d3',      // verde acqua
                torso: '#dda0dd',        // viola
                head: '#87ceeb',         // azzurro
                neck: '#ff9f43',         // arancione
                legs: '#ffffff'          // bianco
            };
            
            // Helper per disegnare linea
            const drawLine = (idx1, idx2, color, lineWidth = 6) => {
                if (lm[idx1] && lm[idx2]) {
                    ctx.beginPath();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = lineWidth;
                    ctx.moveTo(lm[idx1].x * width, lm[idx1].y * height);
                    ctx.lineTo(lm[idx2].x * width, lm[idx2].y * height);
                    ctx.stroke();
                }
            };
            
            // Helper per disegnare punto
            const drawPoint = (idx, color, radius = 8) => {
                if (lm[idx]) {
                    ctx.beginPath();
                    ctx.arc(lm[idx].x * width, lm[idx].y * height, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 0;
                    ctx.stroke();
                    ctx.shadowBlur = 4;
                }
            };
            
            // SPALLE (rosso)
            drawLine(11, 12, segmentColors.shoulders, 8);
            drawPoint(11, segmentColors.shoulders, 10);
            drawPoint(12, segmentColors.shoulders, 10);
            
            // FIANCHI (turchese)
            drawLine(23, 24, segmentColors.hips, 8);
            drawPoint(23, segmentColors.hips, 10);
            drawPoint(24, segmentColors.hips, 10);
            
            // BUSTO (viola)
            drawLine(11, 23, segmentColors.torso, 6);
            drawLine(12, 24, segmentColors.torso, 6);
            
            // BRACCIO ARCO (giallo) - sinistro o destro in base a stance
            if (bowSide === 'left') {
                drawLine(11, 13, segmentColors.bowArm, 6);
                drawLine(13, 15, segmentColors.bowArm, 6);
                drawPoint(13, segmentColors.bowArm);
                drawPoint(15, segmentColors.bowArm);
                // BRACCIO TRAZIONE (verde acqua)
                drawLine(12, 14, segmentColors.drawArm, 6);
                drawLine(14, 16, segmentColors.drawArm, 6);
                drawPoint(14, segmentColors.drawArm);
                drawPoint(16, segmentColors.drawArm);
            } else {
                drawLine(12, 14, segmentColors.bowArm, 6);
                drawLine(14, 16, segmentColors.bowArm, 6);
                drawPoint(14, segmentColors.bowArm);
                drawPoint(16, segmentColors.bowArm);
                // BRACCIO TRAZIONE (verde acqua)
                drawLine(11, 13, segmentColors.drawArm, 6);
                drawLine(13, 15, segmentColors.drawArm, 6);
                drawPoint(13, segmentColors.drawArm);
                drawPoint(15, segmentColors.drawArm);
            }
            
            // COLLO (arancione)
            if (lm[11] && lm[12] && lm[0]) {
                const midX = (lm[11].x + lm[12].x) / 2 * width;
                const midY = (lm[11].y + lm[12].y) / 2 * height;
                ctx.beginPath();
                ctx.strokeStyle = segmentColors.neck;
                ctx.lineWidth = 5;
                ctx.moveTo(midX, midY);
                ctx.lineTo(lm[0].x * width, lm[0].y * height);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(midX, midY, 6, 0, 2 * Math.PI);
                ctx.fillStyle = segmentColors.neck;
                ctx.fill();
            }
            
            // TESTA (azzurro)
            drawPoint(0, segmentColors.head, 8); // naso
            
            // GAMBE (bianco)
            drawLine(23, 25, segmentColors.legs, 5);
            drawLine(25, 27, segmentColors.legs, 5);
            drawLine(24, 26, segmentColors.legs, 5);
            drawLine(26, 28, segmentColors.legs, 5);
            drawPoint(25, segmentColors.legs, 6);
            drawPoint(27, segmentColors.legs, 6);
            drawPoint(26, segmentColors.legs, 6);
            drawPoint(28, segmentColors.legs, 6);
            
            ctx.restore();
        }
        
        // Analisi frame-by-frame con modello selezionato
        async function startAdvancedAnalysis(analysisModel) {
            if (state.isAnalyzing) return;
            
            // Trova la registrazione corrente
            let currentRecording = state.currentRecording;
            
            // Fallback: cerca per URL
            if (!currentRecording) {
                currentRecording = state.recordings.find(r => r.url === elements.playbackVideo.src);
            }
            
            if (!currentRecording) {
                console.error('Nessuna registrazione trovata. state.currentRecording:', state.currentRecording);
                console.error('playbackVideo.src:', elements.playbackVideo.src);
                console.error('recordings:', state.recordings.map(r => r.url));
                alert('Nessuna registrazione selezionata. Seleziona prima un video.');
                return;
            }
            
            // Se la registrazione ha gi lo scheletro integrato nel video, avvisa
            if (currentRecording.hasSkeleton) {
                alert('Questa registrazione ha gi lo scheletro nel video. L\'analisi aggiunger comunque una nuova elaborazione.');
            }
            
            // Se server locale attivo e connesso, usa quello
            if (state.serverMode === 'local' && state.serverIP) {
                await analyzeWithServer(currentRecording, analysisModel);
                return;
            }
            
            // Altrimenti usa analisi locale (browser)
            await analyzeLocally(currentRecording, analysisModel);
        }
        
        // Analisi tramite server locale
        async function analyzeWithServer(currentRecording, analysisModel) {
            const analyzeBtn = document.getElementById('analyzeBtn');
            const video = elements.playbackVideo;
            const wasPlaying = !video.paused;
            
            video.pause();
            state.isAnalyzing = true;
            analyzeBtn.classList.add('analyzing');
            analyzeBtn.querySelector('.analyze-text').textContent = '';
            
            console.log('Analisi con server:', state.serverIP, 'modello:', analysisModel);
            
            try {
                // Converti blob URL in blob
                analyzeBtn.querySelector('.analyze-text').textContent = '';
                
                const response = await fetch(currentRecording.url);
                const blob = await response.blob();
                
                // Prepara form data
                const formData = new FormData();
                formData.append('video', blob, 'video.webm');
                formData.append('model', analysisModel === 'lightning' ? 'pose' : 'holistic');
                formData.append('fps', '30');
                formData.append('quality', analysisModel === 'holistic' ? '2' : '1'); // Qualit massima per holistic
                
                analyzeBtn.querySelector('.analyze-text').textContent = '';
                
                // Invia al server
                const serverResponse = await fetch(`https://${state.serverIP}:5000/api/analyze`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!serverResponse.ok) {
                    throw new Error('Errore server: ' + serverResponse.status);
                }
                
                const results = await serverResponse.json();
                console.log('Risultati server:', results);
                
                // Converti risultati in formato app
                const frameData = {};
                for (const [frameNum, frameInfo] of Object.entries(results.frames)) {
                    if (frameInfo.pose) {
                        // Converti da formato server a formato app
                        const keypoints = frameInfo.pose.map((lm, idx) => ({
                            x: lm.px,
                            y: lm.py,
                            score: lm.visibility || 1,
                            name: getPoseKeypointName(idx)
                        }));
                        
                        frameData[frameNum] = {
                            keypoints: keypoints,
                            time: frameInfo.time,
                            holisticData: {
                                poseLandmarks: frameInfo.pose,
                                leftHandLandmarks: frameInfo.left_hand,
                                rightHandLandmarks: frameInfo.right_hand,
                                faceLandmarks: frameInfo.face
                            }
                        };
                    }
                }
                
                // Crea elaborazione
                const elaboration = createElaboration(currentRecording, analysisModel, frameData, {
                    showGrid: state.showGrid,
                    gridDensity: state.gridDensity,
                    showAlignments: state.showAlignments
                });
                
                state.analyzedFrames = frameData;
                state.currentElaboration = elaboration;
                
                state.isAnalyzing = false;
                analyzeBtn.classList.remove('analyzing');
                analyzeBtn.classList.add('done');
                
                const modelLabels = { holistic: 'H', lightning: 'L', bodypix: 'B' };
                analyzeBtn.querySelector('.analyze-text').textContent = modelLabels[analysisModel] || '';
                elements.modeText.textContent = `Elab. ${modelLabels[analysisModel]}`;
                
                // Forza refresh
                if (Object.keys(frameData).length > 0) {
                    const frameNum = Math.floor(video.currentTime * 30);
                    if (frameData[frameNum]) {
                        const pose = { keypoints: frameData[frameNum].keypoints };
                        state.currentPose = pose;
                        updateAlignments(pose);
                    }
                }
                
                if (wasPlaying) video.play();
                
            } catch (error) {
                console.error('Errore analisi server:', error);
                state.isAnalyzing = false;
                analyzeBtn.classList.remove('analyzing');
                analyzeBtn.querySelector('.analyze-text').textContent = 'ERR';
                
                alert('Errore connessione al server.\nVerifica che il server sia attivo e riprova.\n\nErrore: ' + error.message);
            }
        }
        
        // Nome keypoint per indice
        function getPoseKeypointName(idx) {
            const names = ['nose', 'left_eye_inner', 'left_eye', 'left_eye_outer', 'right_eye_inner', 'right_eye', 'right_eye_outer', 'left_ear', 'right_ear', 'mouth_left', 'mouth_right', 'left_shoulder', 'right_shoulder', 'left_elbow', 'right_elbow', 'left_wrist', 'right_wrist', 'left_pinky', 'right_pinky', 'left_index', 'right_index', 'left_thumb', 'right_thumb', 'left_hip', 'right_hip', 'left_knee', 'right_knee', 'left_ankle', 'right_ankle', 'left_heel', 'right_heel', 'left_foot_index', 'right_foot_index'];
            return names[idx] || `point_${idx}`;
        }
        
        // Analisi locale (nel browser)
        async function analyzeLocally(currentRecording, analysisModel) {
            const analyzeBtn = document.getElementById('analyzeBtn');
            const video = elements.playbackVideo;
            const wasPlaying = !video.paused;
            
            video.pause();
            state.isAnalyzing = true;
            analyzeBtn.classList.add('analyzing');
            analyzeBtn.querySelector('.analyze-text').textContent = '0%';
            
            console.log('Avvio analisi locale con modello:', analysisModel);
            
            // Crea detector temporaneo per l'analisi
            let tempDetector = null;
            let tempHolistic = null;
            let tempBodyPix = null;
            
            try {
                analyzeBtn.querySelector('.analyze-text').textContent = '...';
                
                if (analysisModel === 'holistic') {
                    // Usa MediaPipe Holistic
                    tempHolistic = new Holistic({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic@0.5.1675471629/${file}`
                    });
                    tempHolistic.setOptions({
                        modelComplexity: 1,
                        smoothLandmarks: false,
                        enableSegmentation: false,
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });
                    
                    // Prepara per ricevere risultati
                    let holisticResult = null;
                    tempHolistic.onResults((results) => {
                        holisticResult = results;
                    });
                    
                    await tempHolistic.initialize();
                    console.log('Holistic inizializzato per analisi');
                    
                } else if (analysisModel === 'bodypix') {
                    // Usa BodyPix
                    tempBodyPix = await bodyPix.load({
                        architecture: 'MobileNetV1',
                        outputStride: 16,
                        multiplier: 0.75,
                        quantBytes: 2
                    });
                    console.log('BodyPix caricato per analisi');
                    
                } else {
                    // Default: Lightning
                    tempDetector = await poseDetection.createDetector(
                        poseDetection.SupportedModels.MoveNet,
                        { 
                            modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
                            enableSmoothing: false 
                        }
                    );
                    console.log('Lightning caricato per analisi');
                }
            } catch (error) {
                console.error('Errore caricamento modello per analisi:', error);
                state.isAnalyzing = false;
                analyzeBtn.classList.remove('analyzing');
                analyzeBtn.querySelector('.analyze-text').textContent = 'ERR';
                return;
            }
            
            const duration = video.duration;
            const fps = 30;
            const totalFrames = Math.floor(duration * fps);
            const originalTime = video.currentTime;
            
            const frameData = {};
            
            // Funzione per aspettare che il video sia pronto dopo seek
            const waitForSeek = () => {
                return new Promise(resolve => {
                    const onSeeked = () => {
                        video.removeEventListener('seeked', onSeeked);
                        setTimeout(resolve, 100); // pi tempo per stabilizzare
                    };
                    video.addEventListener('seeked', onSeeked);
                });
            };
            
            for (let frameNum = 0; frameNum < totalFrames && state.isAnalyzing; frameNum++) {
                const targetTime = frameNum / fps;
                video.currentTime = targetTime;
                await waitForSeek();
                
                if (video.readyState < 2) {
                    await new Promise(resolve => {
                        video.oncanplay = resolve;
                    });
                }
                
                try {
                    let keypoints = null;
                    let holisticData = null; // Per salvare tutti i dati Holistic
                    
                    if (analysisModel === 'holistic' && tempHolistic) {
                        // Holistic - usa Promise per aspettare risultato
                        const holisticResult = await new Promise((resolve) => {
                            tempHolistic.onResults((results) => {
                                resolve(results);
                            });
                            tempHolistic.send({ image: video });
                        });
                        
                        // Timeout di sicurezza
                        await new Promise(r => setTimeout(r, 30));
                        
                        if (holisticResult && holisticResult.poseLandmarks) {
                            keypoints = convertHolisticToKeypoints(holisticResult.poseLandmarks, video.videoWidth, video.videoHeight);
                            // Salva TUTTI i dati Holistic per mani e faccia
                            holisticData = {
                                poseLandmarks: holisticResult.poseLandmarks,
                                leftHandLandmarks: holisticResult.leftHandLandmarks || null,
                                rightHandLandmarks: holisticResult.rightHandLandmarks || null,
                                faceLandmarks: holisticResult.faceLandmarks || null
                            };
                        }
                        
                    } else if (analysisModel === 'bodypix' && tempBodyPix) {
                        // BodyPix - estrae pose
                        const segmentation = await tempBodyPix.segmentPersonParts(video);
                        if (segmentation && segmentation.allPoses && segmentation.allPoses.length > 0) {
                            keypoints = segmentation.allPoses[0].keypoints;
                        }
                        
                    } else if (tempDetector) {
                        // Lightning
                        const poses = await tempDetector.estimatePoses(video);
                        if (poses.length > 0) {
                            keypoints = poses[0].keypoints;
                        }
                    }
                    
                    if (keypoints && keypoints.length > 0) {
                        frameData[frameNum] = {
                            keypoints: keypoints,
                            time: targetTime,
                            holisticData: holisticData // Includi dati Holistic se disponibili
                        };
                    }
                } catch (e) {
                    console.error('Errore frame', frameNum, e);
                }
                
                const progress = Math.round(((frameNum + 1) / totalFrames) * 100);
                analyzeBtn.querySelector('.analyze-text').textContent = `${progress}%`;
            }
            
            // Cleanup detector temporaneo
            try {
                if (tempDetector) tempDetector.dispose();
                if (tempHolistic) tempHolistic.close();
            } catch(e) {}
            
            console.log('Analisi completata. Frame analizzati:', Object.keys(frameData).length);
            
            // Crea elaborazione come sottoprodotto (non modifica l'originale)
            const elaboration = createElaboration(currentRecording, analysisModel, frameData, {
                showGrid: state.showGrid,
                gridDensity: state.gridDensity,
                showAlignments: state.showAlignments
            });
            
            // Salva anche nello state per il playback corrente
            state.analyzedFrames = frameData;
            state.currentElaboration = elaboration;
            
            video.currentTime = originalTime;
            state.isAnalyzing = false;
            analyzeBtn.classList.remove('analyzing');
            analyzeBtn.classList.add('done');
            
            // Mostra quale modello  stato usato
            const modelLabels = { holistic: 'H', lightning: 'L', bodypix: 'B' };
            analyzeBtn.querySelector('.analyze-text').textContent = modelLabels[analysisModel] || '';
            
            // Aggiorna indicatore modalit
            elements.modeText.textContent = `Elab. ${modelLabels[analysisModel]}`;
            
            // Forza refresh del frame corrente con i nuovi dati
            if (state.analyzedFrames && Object.keys(state.analyzedFrames).length > 0) {
                const frameNum = Math.floor(originalTime * 30);
                if (state.analyzedFrames[frameNum]) {
                    const pose = { keypoints: state.analyzedFrames[frameNum].keypoints };
                    state.currentPose = pose;
                    updateAlignments(pose);
                    drawFrame(video, pose, true); // forza visualizzazione scheletro
                }
            }
            
            if (wasPlaying) video.play();
        }
        
        // Converte landmarks Holistic in keypoints standard
        function convertHolisticToKeypoints(poseLandmarks, videoWidth, videoHeight) {
            // MediaPipe Holistic pose ha 33 landmarks, mappiamo ai 17 di MoveNet
            const mapping = {
                0: 0,   // nose
                1: 2,   // left_eye (left_eye_outer in holistic)
                2: 5,   // right_eye (right_eye_outer in holistic)
                3: 7,   // left_ear
                4: 8,   // right_ear
                5: 11,  // left_shoulder
                6: 12,  // right_shoulder
                7: 13,  // left_elbow
                8: 14,  // right_elbow
                9: 15,  // left_wrist
                10: 16, // right_wrist
                11: 23, // left_hip
                12: 24, // right_hip
                13: 25, // left_knee
                14: 26, // right_knee
                15: 27, // left_ankle
                16: 28  // right_ankle
            };
            
            const keypoints = [];
            for (let i = 0; i < 17; i++) {
                const holisticIdx = mapping[i];
                if (holisticIdx !== undefined && poseLandmarks[holisticIdx]) {
                    const lm = poseLandmarks[holisticIdx];
                    keypoints.push({
                        x: lm.x * videoWidth,
                        y: lm.y * videoHeight,
                        score: lm.visibility || 0.9,
                        name: Object.keys(KEYPOINTS)[i]
                    });
                } else {
                    keypoints.push({ x: 0, y: 0, score: 0, name: '' });
                }
            }
            return keypoints;
        }
        
        // BlazePose keypoints indices
        const BLAZEPOSE_KEYPOINTS = {
            nose: 0,
            leftEyeInner: 1,
            leftEye: 2,
            leftEyeOuter: 3,
            rightEyeInner: 4,
            rightEye: 5,
            rightEyeOuter: 6,
            leftEar: 7,
            rightEar: 8,
            mouthLeft: 9,
            mouthRight: 10,
            leftShoulder: 11,
            rightShoulder: 12,
            leftElbow: 13,
            rightElbow: 14,
            leftWrist: 15,
            rightWrist: 16,
            leftPinky: 17,
            rightPinky: 18,
            leftIndex: 19,
            rightIndex: 20,
            leftThumb: 21,
            rightThumb: 22,
            leftHip: 23,
            rightHip: 24,
            leftKnee: 25,
            rightKnee: 26,
            leftAnkle: 27,
            rightAnkle: 28,
            leftHeel: 29,
            rightHeel: 30,
            leftFootIndex: 31,
            rightFootIndex: 32
        };
        
        // Connessioni per BlazePose (include mani e collo)
        const BLAZEPOSE_CONNECTIONS = [
            // Viso
            [BLAZEPOSE_KEYPOINTS.nose, BLAZEPOSE_KEYPOINTS.leftEyeInner],
            [BLAZEPOSE_KEYPOINTS.leftEyeInner, BLAZEPOSE_KEYPOINTS.leftEye],
            [BLAZEPOSE_KEYPOINTS.leftEye, BLAZEPOSE_KEYPOINTS.leftEyeOuter],
            [BLAZEPOSE_KEYPOINTS.leftEyeOuter, BLAZEPOSE_KEYPOINTS.leftEar],
            [BLAZEPOSE_KEYPOINTS.nose, BLAZEPOSE_KEYPOINTS.rightEyeInner],
            [BLAZEPOSE_KEYPOINTS.rightEyeInner, BLAZEPOSE_KEYPOINTS.rightEye],
            [BLAZEPOSE_KEYPOINTS.rightEye, BLAZEPOSE_KEYPOINTS.rightEyeOuter],
            [BLAZEPOSE_KEYPOINTS.rightEyeOuter, BLAZEPOSE_KEYPOINTS.rightEar],
            [BLAZEPOSE_KEYPOINTS.mouthLeft, BLAZEPOSE_KEYPOINTS.mouthRight],
            // Collo (connessione tra naso/orecchie e spalle)
            [BLAZEPOSE_KEYPOINTS.leftEar, BLAZEPOSE_KEYPOINTS.leftShoulder],
            [BLAZEPOSE_KEYPOINTS.rightEar, BLAZEPOSE_KEYPOINTS.rightShoulder],
            // Torso
            [BLAZEPOSE_KEYPOINTS.leftShoulder, BLAZEPOSE_KEYPOINTS.rightShoulder],
            [BLAZEPOSE_KEYPOINTS.leftShoulder, BLAZEPOSE_KEYPOINTS.leftHip],
            [BLAZEPOSE_KEYPOINTS.rightShoulder, BLAZEPOSE_KEYPOINTS.rightHip],
            [BLAZEPOSE_KEYPOINTS.leftHip, BLAZEPOSE_KEYPOINTS.rightHip],
            // Braccio sinistro
            [BLAZEPOSE_KEYPOINTS.leftShoulder, BLAZEPOSE_KEYPOINTS.leftElbow],
            [BLAZEPOSE_KEYPOINTS.leftElbow, BLAZEPOSE_KEYPOINTS.leftWrist],
            // Mano sinistra
            [BLAZEPOSE_KEYPOINTS.leftWrist, BLAZEPOSE_KEYPOINTS.leftThumb],
            [BLAZEPOSE_KEYPOINTS.leftWrist, BLAZEPOSE_KEYPOINTS.leftIndex],
            [BLAZEPOSE_KEYPOINTS.leftWrist, BLAZEPOSE_KEYPOINTS.leftPinky],
            [BLAZEPOSE_KEYPOINTS.leftIndex, BLAZEPOSE_KEYPOINTS.leftPinky],
            // Braccio destro
            [BLAZEPOSE_KEYPOINTS.rightShoulder, BLAZEPOSE_KEYPOINTS.rightElbow],
            [BLAZEPOSE_KEYPOINTS.rightElbow, BLAZEPOSE_KEYPOINTS.rightWrist],
            // Mano destra
            [BLAZEPOSE_KEYPOINTS.rightWrist, BLAZEPOSE_KEYPOINTS.rightThumb],
            [BLAZEPOSE_KEYPOINTS.rightWrist, BLAZEPOSE_KEYPOINTS.rightIndex],
            [BLAZEPOSE_KEYPOINTS.rightWrist, BLAZEPOSE_KEYPOINTS.rightPinky],
            [BLAZEPOSE_KEYPOINTS.rightIndex, BLAZEPOSE_KEYPOINTS.rightPinky],
            // Gamba sinistra
            [BLAZEPOSE_KEYPOINTS.leftHip, BLAZEPOSE_KEYPOINTS.leftKnee],
            [BLAZEPOSE_KEYPOINTS.leftKnee, BLAZEPOSE_KEYPOINTS.leftAnkle],
            [BLAZEPOSE_KEYPOINTS.leftAnkle, BLAZEPOSE_KEYPOINTS.leftHeel],
            [BLAZEPOSE_KEYPOINTS.leftAnkle, BLAZEPOSE_KEYPOINTS.leftFootIndex],
            [BLAZEPOSE_KEYPOINTS.leftHeel, BLAZEPOSE_KEYPOINTS.leftFootIndex],
            // Gamba destra
            [BLAZEPOSE_KEYPOINTS.rightHip, BLAZEPOSE_KEYPOINTS.rightKnee],
            [BLAZEPOSE_KEYPOINTS.rightKnee, BLAZEPOSE_KEYPOINTS.rightAnkle],
            [BLAZEPOSE_KEYPOINTS.rightAnkle, BLAZEPOSE_KEYPOINTS.rightHeel],
            [BLAZEPOSE_KEYPOINTS.rightAnkle, BLAZEPOSE_KEYPOINTS.rightFootIndex],
            [BLAZEPOSE_KEYPOINTS.rightHeel, BLAZEPOSE_KEYPOINTS.rightFootIndex]
        ];
        
        // Converte BlazePose per uso con drawSkeleton HD
        function convertBlazePoseForHD(blazePose) {
            return {
                keypoints: blazePose.keypoints,
                isHD: true
            };
        }
        
        // Converte BlazePose (33 punti) in MoveNet (17 punti) per compatibilit allineamenti
        function convertBlazePoseToMoveNet(blazePose, videoWidth, videoHeight) {
            const bkp = blazePose.keypoints;
            
            if (!bkp || bkp.length < 33) {
                console.warn('BlazePose keypoints non validi:', bkp?.length);
                return null;
            }
            
            // BlazePose pu restituire coordinate normalizzate (0-1) o in pixel
            // Controlliamo se dobbiamo convertire
            const firstKp = bkp[0];
            const needsScaling = (firstKp.x <= 1 && firstKp.y <= 1) || isNaN(firstKp.x);
            
            // Se le coordinate sono NaN, proviamo a usare le coordinate 3D normalizzate
            const getCoords = (kp) => {
                let x = kp.x;
                let y = kp.y;
                
                // Se x,y sono NaN ma abbiamo coordinate normalizzate
                if (isNaN(x) || isNaN(y)) {
                    // BlazePose a volte mette le coordinate in modo diverso
                    if (kp.xNormalized !== undefined) {
                        x = kp.xNormalized * videoWidth;
                        y = kp.yNormalized * videoHeight;
                    }
                } else if (needsScaling && x <= 1 && y <= 1) {
                    // Coordinate normalizzate 0-1
                    x = x * videoWidth;
                    y = y * videoHeight;
                }
                
                return { x, y, score: kp.score || 0 };
            };
            
            // Mapping indici BlazePose -> MoveNet
            const mapping = [
                0,  // nose
                2,  // left eye
                5,  // right eye
                7,  // left ear
                8,  // right ear
                11, // left shoulder
                12, // right shoulder
                13, // left elbow
                14, // right elbow
                15, // left wrist
                16, // right wrist
                23, // left hip
                24, // right hip
                25, // left knee
                26, // right knee
                27, // left ankle
                28  // right ankle
            ];
            
            const keypoints = mapping.map((blazeIdx, moveNetIdx) => {
                const bp = bkp[blazeIdx];
                if (!bp) return { x: 0, y: 0, score: 0, name: '' };
                const coords = getCoords(bp);
                return {
                    x: coords.x,
                    y: coords.y,
                    score: coords.score,
                    name: Object.keys(KEYPOINTS)[moveNetIdx]
                };
            });
            
            // Converti anche tutti i 33 punti per il disegno completo
            const keypointsFull = bkp.map(kp => {
                const coords = getCoords(kp);
                return {
                    x: coords.x,
                    y: coords.y,
                    score: kp.score || 0,
                    name: kp.name
                };
            });
            
            return { 
                keypoints,
                keypointsFull,
                isHD: true
            };
        }

        function updatePlaybackUI() {
            const video = elements.playbackVideo;
            const progress = (video.currentTime / video.duration) * 100;
            
            elements.timelineProgress.style.width = `${progress}%`;
            elements.timelineHandle.style.left = `${progress}%`;
            
            const currentFrame = Math.floor(video.currentTime * 30);
            const totalFrames = Math.floor(video.duration * 30);
            elements.frameCounter.textContent = `${currentFrame} / ${totalFrames}`;
        }

        function backToLive() {
            state.isPlayback = false;
            state.isPlaying = false;
            state.isAnalyzing = false;
            state.currentRecording = null;
            state.analyzedFrames = {};
            
            elements.playbackVideo.pause();
            elements.playbackVideo.src = '';
            elements.playbackVideo.style.display = 'none';
            elements.video.style.display = 'block';
            
            elements.playbackControls.classList.remove('active');
            elements.liveControls.style.display = 'flex';
            
            // Nascondi controlli playback nel menu fullscreen
            document.getElementById('fsPlaybackSection').style.display = 'none';
            
            elements.modeIndicator.classList.remove('playback');
            elements.modeText.textContent = 'Live';
            
            // Reset pulsante analisi
            const analyzeBtn = document.getElementById('analyzeBtn');
            analyzeBtn.classList.remove('analyzing', 'done');
            analyzeBtn.querySelector('.analyze-text').textContent = 'HD';
            
            elements.canvas.width = elements.video.videoWidth;
            elements.canvas.height = elements.video.videoHeight;
            
            detectPose();
        }

        function deleteRecording(id) {
            const index = state.recordings.findIndex(r => r.id === id);
            if (index > -1) {
                URL.revokeObjectURL(state.recordings[index].url);
                state.recordings.splice(index, 1);
                updateRecordingsList();
                
                if (state.currentRecording && state.currentRecording.id === id) {
                    backToLive();
                }
            }
        }

        function takeScreenshot() {
            const link = document.createElement('a');
            link.download = `archery-${Date.now()}.png`;
            link.href = elements.canvas.toDataURL('image/png');
            link.click();
        }

        // Event Listeners
        function setupEventListeners() {
            // Bow type selector
            document.querySelectorAll('.bow-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.bow-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.bowType = btn.dataset.bow;
                    
                    document.documentElement.style.setProperty('--accent-current', 
                        bowConfig[state.bowType].color);
                });
            });
            
            // Stance selector
            document.querySelectorAll('.stance-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.stance-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.stance = btn.dataset.stance;
                });
            });
            
            // Model selector
            document.querySelectorAll('.model-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const newModel = btn.dataset.model;
                    if (newModel === state.modelType) return;
                    
                    // Mostra loading con nome corretto
                    const modelNames = {
                        'thunder': 'MoveNet Thunder',
                        'lightning': 'MoveNet Lightning', 
                        'holistic': 'MediaPipe Holistic',
                        'bodypix': 'BodyPix'
                    };
                    elements.loadingOverlay.classList.remove('hidden');
                    elements.loadingOverlay.querySelector('.loading-text').textContent = 
                        `Caricamento ${modelNames[newModel] || newModel}...`;
                    
                    document.querySelectorAll('.model-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    try {
                        await loadModel(newModel);
                    } catch (error) {
                        console.error('Errore caricamento modello:', error);
                        alert('Errore nel caricamento del modello. Riprova.');
                    }
                    
                    elements.loadingOverlay.classList.add('hidden');
                });
            });
            
            // Camera selector
            elements.cameraSelect.addEventListener('change', (e) => {
                if (e.target.value) {
                    startCamera(e.target.value);
                }
            });
            
            // Record button
            elements.recordBtn.addEventListener('click', () => {
                if (state.isRecording) {
                    stopRecording();
                } else {
                    startRecording();
                }
            });
            
            // Flip button
            elements.flipBtn.addEventListener('click', () => {
                state.flipVideo = !state.flipVideo;
                elements.flipBtn.style.background = state.flipVideo ? 
                    bowConfig[state.bowType].color : '';
            });
            
            // Skeleton toggle
            elements.skeletonBtn.addEventListener('click', () => {
                state.showSkeleton = !state.showSkeleton;
                elements.skeletonBtn.style.background = state.showSkeleton ? 
                    bowConfig[state.bowType].color : '';
            });
            
            // Grid toggle
            elements.gridBtn.addEventListener('click', () => {
                state.showGrid = !state.showGrid;
                elements.gridBtn.style.background = state.showGrid ? 
                    bowConfig[state.bowType].color : '';
            });
            
            // Alignments toggle
            document.getElementById('alignmentsBtn').addEventListener('click', () => {
                state.showAlignments = !state.showAlignments;
                document.getElementById('alignmentsBtn').style.background = state.showAlignments ? 
                    bowConfig[state.bowType].color : '';
                document.getElementById('anglesOverlay').style.display = state.showAlignments ? 'flex' : 'none';
            });
            
            // Grid density
            document.getElementById('gridDensitySelect').addEventListener('change', (e) => {
                state.gridDensity = parseInt(e.target.value);
            });
            
            // Screenshot
            elements.screenshotBtn.addEventListener('click', takeScreenshot);
            
            // Fullscreen
            elements.fullscreenBtn.addEventListener('click', () => {
                const container = document.querySelector('.video-section');
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    container.requestFullscreen();
                }
            });
            
            // Playback Fullscreen button
            document.getElementById('playbackFullscreenBtn').addEventListener('click', () => {
                const container = document.querySelector('.video-section');
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    container.requestFullscreen();
                }
            });
            
            // Hamburger menu toggle
            const hamburgerBtn = document.getElementById('hamburgerBtn');
            const fullscreenMenu = document.getElementById('fullscreenMenu');
            const menuOverlay = document.getElementById('menuOverlay');
            
            hamburgerBtn.addEventListener('click', () => {
                hamburgerBtn.classList.toggle('open');
                fullscreenMenu.classList.toggle('open');
                menuOverlay.classList.toggle('open');
            });
            
            menuOverlay.addEventListener('click', () => {
                hamburgerBtn.classList.remove('open');
                fullscreenMenu.classList.remove('open');
                menuOverlay.classList.remove('open');
            });
            
            // Fullscreen menu - Bow type
            document.querySelectorAll('.fs-bow-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.fs-bow-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.bow-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const bowBtn = document.querySelector(`.bow-btn[data-bow="${btn.dataset.bow}"]`);
                    if (bowBtn) bowBtn.classList.add('active');
                    state.bowType = btn.dataset.bow;
                    document.documentElement.style.setProperty('--accent-current', bowConfig[state.bowType].color);
                });
            });
            
            // Fullscreen menu - Stance
            document.querySelectorAll('.fs-stance-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.fs-stance-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.stance-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const stanceBtn = document.querySelector(`.stance-btn[data-stance="${btn.dataset.stance}"]`);
                    if (stanceBtn) stanceBtn.classList.add('active');
                    state.stance = btn.dataset.stance;
                });
            });
            
            // Fullscreen menu - Model
            document.querySelectorAll('.fs-model-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const newModel = btn.dataset.model;
                    if (newModel === state.modelType) return;
                    
                    // Chiudi menu temporaneamente
                    hamburgerBtn.classList.remove('open');
                    fullscreenMenu.classList.remove('open');
                    menuOverlay.classList.remove('open');
                    
                    // Mostra loading
                    const modelNames = {
                        'thunder': 'MoveNet Thunder',
                        'lightning': 'MoveNet Lightning', 
                        'holistic': 'MediaPipe Holistic',
                        'bodypix': 'BodyPix'
                    };
                    elements.loadingOverlay.classList.remove('hidden');
                    elements.loadingOverlay.querySelector('.loading-text').textContent = 
                        `Caricamento ${modelNames[newModel] || newModel}...`;
                    
                    document.querySelectorAll('.fs-model-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.model-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const modelBtn = document.querySelector(`.model-btn[data-model="${newModel}"]`);
                    if (modelBtn) modelBtn.classList.add('active');
                    
                    try {
                        await loadModel(newModel);
                    } catch (error) {
                        console.error('Errore caricamento modello:', error);
                    }
                    
                    elements.loadingOverlay.classList.add('hidden');
                    
                    // Torna a fullscreen
                    const container = document.querySelector('.video-section');
                    if (!document.fullscreenElement) {
                        container.requestFullscreen();
                    }
                });
            });
            
            // Fullscreen menu - Toggle buttons
            document.getElementById('fsSkeletonBtn').addEventListener('click', function() {
                state.showSkeleton = !state.showSkeleton;
                this.classList.toggle('active', state.showSkeleton);
                elements.skeletonBtn.style.background = state.showSkeleton ? bowConfig[state.bowType].color : '';
            });
            
            document.getElementById('fsGridBtn').addEventListener('click', function() {
                state.showGrid = !state.showGrid;
                this.classList.toggle('active', state.showGrid);
                elements.gridBtn.style.background = state.showGrid ? bowConfig[state.bowType].color : '';
            });
            
            document.getElementById('fsAlignBtn').addEventListener('click', function() {
                state.showAlignments = !state.showAlignments;
                this.classList.toggle('active', state.showAlignments);
                document.getElementById('anglesOverlay').style.display = state.showAlignments ? 'flex' : 'none';
                document.getElementById('alignmentsBtn').style.background = state.showAlignments ? bowConfig[state.bowType].color : '';
            });
            
            document.getElementById('fsFlipBtn').addEventListener('click', function() {
                state.flipVideo = !state.flipVideo;
                this.classList.toggle('active', state.flipVideo);
                elements.flipBtn.style.background = state.flipVideo ? bowConfig[state.bowType].color : '';
            });
            
            // Fullscreen menu - Grid density
            document.querySelectorAll('.fs-grid-density').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.fs-grid-density').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.gridDensity = parseInt(btn.dataset.density);
                    document.getElementById('gridDensitySelect').value = btn.dataset.density;
                });
            });
            
            // Fullscreen menu - Actions
            document.getElementById('fsRecordBtn').addEventListener('click', () => {
                if (state.isRecording) {
                    stopRecording();
                } else {
                    startRecording();
                }
            });
            
            document.getElementById('fsScreenshotBtn').addEventListener('click', takeScreenshot);
            
            document.getElementById('fsExitBtn').addEventListener('click', () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
                hamburgerBtn.classList.remove('open');
                fullscreenMenu.classList.remove('open');
                menuOverlay.classList.remove('open');
            });
            
            // Fullscreen Playback Controls
            document.getElementById('fsBackToLiveBtn').addEventListener('click', () => {
                backToLive();
                hamburgerBtn.classList.remove('open');
                fullscreenMenu.classList.remove('open');
                menuOverlay.classList.remove('open');
            });
            
            document.getElementById('fsPlayPauseBtn').addEventListener('click', () => {
                if (elements.playbackVideo.paused) {
                    elements.playbackVideo.play();
                    document.getElementById('fsPlayPauseBtn').textContent = ' Pausa';
                } else {
                    elements.playbackVideo.pause();
                    document.getElementById('fsPlayPauseBtn').textContent = ' Play';
                }
            });
            
            document.getElementById('fsFramePrevBtn').addEventListener('click', () => {
                elements.playbackVideo.pause();
                elements.playbackVideo.currentTime = Math.max(0, elements.playbackVideo.currentTime - (1/30));
                document.getElementById('fsPlayPauseBtn').textContent = ' Play';
            });
            
            document.getElementById('fsFrameNextBtn').addEventListener('click', () => {
                elements.playbackVideo.pause();
                elements.playbackVideo.currentTime = Math.min(elements.playbackVideo.duration, elements.playbackVideo.currentTime + (1/30));
                document.getElementById('fsPlayPauseBtn').textContent = ' Play';
            });
            
            // Fullscreen Speed Controls
            document.querySelectorAll('.fs-speed-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const speed = parseFloat(btn.dataset.speed);
                    elements.playbackVideo.playbackRate = speed;
                    document.querySelectorAll('.fs-speed-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    // Sincronizza con speed-btn normali
                    document.querySelectorAll('.speed-btn').forEach(b => {
                        b.classList.toggle('active', parseFloat(b.dataset.speed) === speed);
                    });
                });
            });
            
            // Fullscreen Analyze buttons
            document.querySelectorAll('.fs-analyze-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const model = btn.dataset.model;
                    // Chiudi menu
                    hamburgerBtn.classList.remove('open');
                    fullscreenMenu.classList.remove('open');
                    menuOverlay.classList.remove('open');
                    // Avvia analisi
                    startAdvancedAnalysis(model);
                });
            });
            
            // Fullscreen Playback Grid buttons
            document.querySelectorAll('.fs-pb-grid').forEach(btn => {
                btn.addEventListener('click', () => {
                    const density = parseInt(btn.dataset.density);
                    
                    if (density === 0) {
                        state.showGrid = false;
                    } else {
                        state.showGrid = true;
                        state.gridDensity = density;
                    }
                    
                    // Aggiorna active states
                    document.querySelectorAll('.fs-pb-grid').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    // Sincronizza con altri controlli griglia
                    document.querySelectorAll('.grid-option').forEach(b => {
                        b.classList.toggle('active', parseInt(b.dataset.density) === density);
                    });
                    document.querySelectorAll('.fs-grid-density').forEach(b => {
                        b.classList.toggle('active', parseInt(b.dataset.density) === density);
                    });
                });
            });
            
            // Playback controls
            elements.backToLiveBtn.addEventListener('click', backToLive);
            
            // Menu Griglia Playback - mostra dropdown al click
            const playbackGridBtn = document.getElementById('playbackGridBtn');
            const gridDropdown = document.getElementById('gridDropdown');
            
            playbackGridBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                gridDropdown.classList.toggle('show');
                // Chiudi dropdown analisi se aperto
                document.getElementById('analyzeDropdown').classList.remove('show');
            });
            
            // Opzioni griglia
            document.querySelectorAll('.grid-option').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const density = parseInt(btn.dataset.density);
                    
                    if (density === 0) {
                        // OFF
                        state.showGrid = false;
                        playbackGridBtn.style.background = '';
                        elements.gridBtn.style.background = '';
                    } else {
                        state.showGrid = true;
                        state.gridDensity = density; // Usa gridDensity come nel live
                        playbackGridBtn.style.background = 'var(--accent-current)';
                        elements.gridBtn.style.background = 'var(--accent-current)';
                        // Sincronizza select nel live
                        document.getElementById('gridDensitySelect').value = density;
                    }
                    
                    // Aggiorna active state
                    document.querySelectorAll('.grid-option').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    // Sincronizza con fs-grid-density
                    document.querySelectorAll('.fs-grid-density').forEach(b => {
                        b.classList.toggle('active', parseInt(b.dataset.density) === density);
                    });
                    
                    gridDropdown.classList.remove('show');
                });
            });
            
            // Menu Analisi - mostra dropdown al click
            const analyzeBtn = document.getElementById('analyzeBtn');
            const analyzeDropdown = document.getElementById('analyzeDropdown');
            
            analyzeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                analyzeDropdown.classList.toggle('show');
                // Chiudi dropdown griglia se aperto
                gridDropdown.classList.remove('show');
            });
            
            // Opzioni analisi
            document.querySelectorAll('.analyze-option').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const model = btn.dataset.model;
                    analyzeDropdown.classList.remove('show');
                    startAdvancedAnalysis(model);
                });
            });
            
            // Chiudi dropdown cliccando fuori
            document.addEventListener('click', () => {
                analyzeDropdown.classList.remove('show');
                gridDropdown.classList.remove('show');
            });
            
            elements.playPauseBtn.addEventListener('click', () => {
                if (elements.playbackVideo.paused) {
                    elements.playbackVideo.play();
                    state.isPlaying = true;
                } else {
                    elements.playbackVideo.pause();
                    state.isPlaying = false;
                }
                updatePlayPauseIcon();
            });
            
            elements.framePrevBtn.addEventListener('click', () => {
                elements.playbackVideo.currentTime = Math.max(0, 
                    elements.playbackVideo.currentTime - 1/30);
            });
            
            elements.frameNextBtn.addEventListener('click', () => {
                elements.playbackVideo.currentTime = Math.min(
                    elements.playbackVideo.duration,
                    elements.playbackVideo.currentTime + 1/30);
            });
            
            // Timeline scrubbing
            let isDragging = false;
            
            elements.timeline.addEventListener('mousedown', (e) => {
                isDragging = true;
                seekToPosition(e);
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) seekToPosition(e);
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            elements.timeline.addEventListener('touchstart', (e) => {
                isDragging = true;
                seekToPosition(e.touches[0]);
            });
            
            document.addEventListener('touchmove', (e) => {
                if (isDragging) seekToPosition(e.touches[0]);
            });
            
            document.addEventListener('touchend', () => {
                isDragging = false;
            });
            
            function seekToPosition(e) {
                const rect = elements.timeline.getBoundingClientRect();
                const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                elements.playbackVideo.currentTime = percent * elements.playbackVideo.duration;
            }
            
            // Speed controls
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.playbackSpeed = parseFloat(btn.dataset.speed);
                    elements.playbackVideo.playbackRate = state.playbackSpeed;
                });
            });
            
            // Playback video events
            elements.playbackVideo.addEventListener('play', () => {
                state.isPlaying = true;
                updatePlayPauseIcon();
            });
            
            elements.playbackVideo.addEventListener('pause', () => {
                state.isPlaying = false;
                updatePlayPauseIcon();
            });
            
            elements.playbackVideo.addEventListener('ended', () => {
                state.isPlaying = false;
                updatePlayPauseIcon();
            });
        }

        function updatePlayPauseIcon() {
            const icon = elements.playPauseBtn.querySelector('svg');
            if (state.isPlaying) {
                icon.innerHTML = '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';
            } else {
                icon.innerHTML = '<polygon points="8,5 19,12 8,19"/>';
            }
        }
        
        // ============ SETTINGS MODAL ============
        function openSettingsModal() {
            const bowType = state.bowType;
            const thresholds = bowConfig[bowType].thresholds;
            
            document.getElementById('settingsBowType').textContent = 
                bowType === 'olympic' ? 'Olimpico' : bowType === 'compound' ? 'Compound' : 'Nudo';
            
            document.getElementById('shouldersGood').value = thresholds.shoulders.good;
            document.getElementById('shouldersWarning').value = thresholds.shoulders.warning;
            document.getElementById('hipsGood').value = thresholds.hips.good;
            document.getElementById('hipsWarning').value = thresholds.hips.warning;
            document.getElementById('bowArmGood').value = thresholds.bowArm.good;
            document.getElementById('bowArmWarning').value = thresholds.bowArm.warning;
            document.getElementById('torsoGood').value = thresholds.torso.good;
            document.getElementById('torsoWarning').value = thresholds.torso.warning;
            document.getElementById('headGood').value = thresholds.head.good;
            document.getElementById('headWarning').value = thresholds.head.warning;
            
            document.getElementById('settingsModal').classList.add('open');
        }
        
        function closeSettingsModal() {
            document.getElementById('settingsModal').classList.remove('open');
        }
        
        function saveSettings() {
            const bowType = state.bowType;
            
            bowConfig[bowType].thresholds.shoulders.good = parseInt(document.getElementById('shouldersGood').value);
            bowConfig[bowType].thresholds.shoulders.warning = parseInt(document.getElementById('shouldersWarning').value);
            bowConfig[bowType].thresholds.hips.good = parseInt(document.getElementById('hipsGood').value);
            bowConfig[bowType].thresholds.hips.warning = parseInt(document.getElementById('hipsWarning').value);
            bowConfig[bowType].thresholds.bowArm.good = parseInt(document.getElementById('bowArmGood').value);
            bowConfig[bowType].thresholds.bowArm.warning = parseInt(document.getElementById('bowArmWarning').value);
            bowConfig[bowType].thresholds.torso.good = parseInt(document.getElementById('torsoGood').value);
            bowConfig[bowType].thresholds.torso.warning = parseInt(document.getElementById('torsoWarning').value);
            bowConfig[bowType].thresholds.head.good = parseInt(document.getElementById('headGood').value);
            bowConfig[bowType].thresholds.head.warning = parseInt(document.getElementById('headWarning').value);
            
            saveThresholds();
            closeSettingsModal();
        }
        
        function resetSettings() {
            const bowType = state.bowType;
            bowConfig[bowType].thresholds = JSON.parse(JSON.stringify(defaultThresholds[bowType].thresholds));
            openSettingsModal(); // Refresh
        }
        
        // ============ PIN MODAL ============
        function setupPinInputs(inputs, onComplete) {
            inputs.forEach((input, index) => {
                input.addEventListener('input', (e) => {
                    if (e.target.value.length === 1) {
                        if (index < inputs.length - 1) {
                            inputs[index + 1].focus();
                        } else {
                            const pin = Array.from(inputs).map(i => i.value).join('');
                            onComplete(pin);
                        }
                    }
                });
                
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Backspace' && !e.target.value && index > 0) {
                        inputs[index - 1].focus();
                    }
                });
            });
        }
        
        function openPinModal() {
            if (!appPin) {
                // No PIN set, show set PIN modal
                document.getElementById('setPinModal').classList.add('open');
                const inputs = document.querySelectorAll('[data-newpin]');
                inputs.forEach(i => i.value = '');
                inputs[0].focus();
            } else {
                // PIN exists, verify
                document.getElementById('pinModal').classList.add('open');
                document.getElementById('pinError').textContent = '';
                const inputs = document.querySelectorAll('[data-pin]');
                inputs.forEach(i => i.value = '');
                inputs[0].focus();
            }
        }
        
        function closePinModal() {
            document.getElementById('pinModal').classList.remove('open');
        }
        
        function closeSetPinModal() {
            document.getElementById('setPinModal').classList.remove('open');
        }
        
        function verifyPin(pin) {
            if (pin === appPin) {
                closePinModal();
                openAthletesModal();
            } else {
                document.getElementById('pinError').textContent = 'PIN errato. Riprova.';
                const inputs = document.querySelectorAll('[data-pin]');
                inputs.forEach(i => i.value = '');
                inputs[0].focus();
            }
        }
        
        function setNewPin() {
            const inputs = document.querySelectorAll('[data-newpin]');
            const pin = Array.from(inputs).map(i => i.value).join('');
            if (pin.length === 4) {
                appPin = pin;
                localStorage.setItem('archeryPin', pin);
                closeSetPinModal();
                openAthletesModal();
            }
        }
        
        // ============ ATHLETES MODAL ============
        function openAthletesModal() {
            renderAthletesList();
            document.getElementById('athletesModal').classList.add('open');
        }
        
        function closeAthletesModal() {
            document.getElementById('athletesModal').classList.remove('open');
        }
        
        function renderAthletesList() {
            const list = document.getElementById('athletesList');
            if (athletes.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: var(--text-muted); padding: 1rem;">Nessun atleta registrato</p>';
                return;
            }
            
            const bowNames = { olympic: 'Olimpico', compound: 'Compound', barebow: 'Nudo' };
            
            list.innerHTML = athletes.map((athlete, index) => `
                <div class="athlete-item ${currentAthlete && currentAthlete.id === athlete.id ? 'selected' : ''}" data-id="${athlete.id}">
                    <div class="athlete-info">
                        <span class="athlete-name">${athlete.name}</span>
                        <span class="athlete-bow">${bowNames[athlete.bow]}</span>
                    </div>
                    <div class="athlete-actions">
                        <button class="athlete-action-btn select-athlete" title="Seleziona"></button>
                        <button class="athlete-action-btn delete delete-athlete" title="Elimina"></button>
                    </div>
                </div>
            `).join('');
            
            // Event listeners
            list.querySelectorAll('.select-athlete').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const id = btn.closest('.athlete-item').dataset.id;
                    selectAthlete(id);
                });
            });
            
            list.querySelectorAll('.delete-athlete').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const id = btn.closest('.athlete-item').dataset.id;
                    deleteAthlete(id);
                });
            });
            
            list.querySelectorAll('.athlete-item').forEach(item => {
                item.addEventListener('click', () => {
                    selectAthlete(item.dataset.id);
                });
            });
        }
        
        function addAthlete() {
            const name = document.getElementById('newAthleteName').value.trim();
            const bow = document.getElementById('newAthleteBow').value;
            
            if (!name) {
                alert('Inserisci il nome dell\'atleta');
                return;
            }
            
            const athlete = {
                id: Date.now().toString(),
                name: name,
                bow: bow,
                createdAt: new Date().toISOString()
            };
            
            athletes.push(athlete);
            saveAthletes();
            
            document.getElementById('newAthleteName').value = '';
            renderAthletesList();
            
            // Auto-select new athlete
            selectAthlete(athlete.id);
        }
        
        function selectAthlete(id) {
            const athlete = athletes.find(a => a.id === id);
            if (athlete) {
                currentAthlete = athlete;
                saveCurrentAthlete();
                
                // Change bow type to athlete's preference
                state.bowType = athlete.bow;
                document.documentElement.style.setProperty('--accent-current', bowConfig[athlete.bow].color);
                document.querySelectorAll('.bow-btn').forEach(b => b.classList.remove('active'));
                document.querySelector(`.bow-btn[data-bow="${athlete.bow}"]`).classList.add('active');
                
                closeAthletesModal();
            }
        }
        
        function deleteAthlete(id) {
            if (confirm('Sei sicuro di voler eliminare questo atleta?')) {
                athletes = athletes.filter(a => a.id !== id);
                saveAthletes();
                
                if (currentAthlete && currentAthlete.id === id) {
                    currentAthlete = null;
                    saveCurrentAthlete();
                }
                
                renderAthletesList();
            }
        }
        
        function deselectAthlete() {
            currentAthlete = null;
            saveCurrentAthlete();
            closeAthletesModal();
        }

        // Initialize skeleton button as active
        document.addEventListener('DOMContentLoaded', () => {
            elements.skeletonBtn.style.background = bowConfig[state.bowType].color;
            
            // Inizializza pulsante allineamenti con stato corretto
            document.getElementById('alignmentsBtn').style.background = state.showAlignments ? 
                bowConfig[state.bowType].color : '';
            
            // Update current athlete display
            if (currentAthlete) {
                document.getElementById('currentAthleteName').textContent = currentAthlete.name;
            }
            
            // Header hamburger menu
            const headerHamburger = document.getElementById('headerHamburger');
            const headerDropdown = document.getElementById('headerDropdown');
            
            headerHamburger.addEventListener('click', (e) => {
                e.stopPropagation();
                headerHamburger.classList.toggle('open');
                headerDropdown.classList.toggle('open');
            });
            
            // Close header dropdown on outside click
            document.addEventListener('click', (e) => {
                if (!headerDropdown.contains(e.target) && !headerHamburger.contains(e.target)) {
                    headerHamburger.classList.remove('open');
                    headerDropdown.classList.remove('open');
                }
            });
            
            // Header bow buttons
            document.querySelectorAll('.hdr-bow-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.hdr-bow-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.bowType = btn.dataset.bow;
                    document.documentElement.style.setProperty('--accent-current', `var(--accent-${state.bowType})`);
                    // Sync con fullscreen menu
                    document.querySelectorAll('.fs-bow-btn').forEach(b => {
                        b.classList.toggle('active', b.dataset.bow === state.bowType);
                    });
                });
            });
            
            // Header stance buttons
            document.querySelectorAll('.hdr-stance-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.hdr-stance-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.archerPosition = btn.dataset.stance;
                    // Sync con fullscreen menu
                    document.querySelectorAll('.fs-stance-btn').forEach(b => {
                        b.classList.toggle('active', b.dataset.stance === state.archerPosition);
                    });
                });
            });
            
            // Server IP input - salva quando cambia
            document.getElementById('serverIP').addEventListener('change', (e) => {
                state.serverIP = e.target.value.trim();
                localStorage.setItem('serverIP', state.serverIP);
            });
            
            // Server Archive Button - apre modal archivio
            document.getElementById('serverArchiveBtn').addEventListener('click', async () => {
                const ip = document.getElementById('serverIP').value.trim();
                
                if (!ip) {
                    alert('Inserisci l\'indirizzo IP del server!\n\nLo trovi nella finestra del server sul PC.');
                    return;
                }
                
                state.serverIP = ip;
                localStorage.setItem('serverIP', ip);
                
                // Apri modal e carica atleti
                document.getElementById('archivioModal').classList.add('open');
                await archivioCaricaAtleti();
            });
            
            // Archivio modal close
            document.getElementById('archivioModalClose').addEventListener('click', () => {
                document.getElementById('archivioModal').classList.remove('open');
            });
            
            // Archivio tabs
            document.querySelectorAll('.archivio-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.archivio-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    const tabName = tab.dataset.tab;
                    document.getElementById('tabAtleti').style.display = tabName === 'atleti' ? 'block' : 'none';
                    document.getElementById('tabVideo').style.display = tabName === 'video' ? 'block' : 'none';
                });
            });
            
            // Aggiungi atleta
            document.getElementById('btnAggiungiAtleta').addEventListener('click', async () => {
                const nome = document.getElementById('nuovoAtletaNome').value.trim();
                if (!nome) return;
                
                try {
                    const response = await fetch(`https://${state.serverIP}:5000/api/atleti`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ nome })
                    });
                    
                    if (response.ok) {
                        document.getElementById('nuovoAtletaNome').value = '';
                        await archivioCaricaAtleti();
                    } else {
                        const err = await response.json();
                        alert(err.error || 'Errore');
                    }
                } catch (e) {
                    alert('Errore connessione server');
                }
            });
            
            // Torna ad atleti
            document.getElementById('btnTornaAtleti').addEventListener('click', () => {
                document.querySelector('.archivio-tab[data-tab="atleti"]').click();
            });
            
            // Invia video al server
            document.getElementById('btnInviaVideo').addEventListener('click', async () => {
                if (!state.currentRecording) {
                    alert('Seleziona prima un video dalla lista registrazioni');
                    return;
                }
                
                const atleta = state.currentAthlete || document.getElementById('athleteName').value.trim();
                if (!atleta) {
                    alert('Inserisci il nome dell\'atleta');
                    return;
                }
                
                try {
                    document.getElementById('btnInviaVideo').textContent = ' Invio...';
                    
                    // Fetch blob from URL
                    const response = await fetch(state.currentRecording.url);
                    const blob = await response.blob();
                    
                    // Upload
                    const formData = new FormData();
                    formData.append('video', blob, 'video.webm');
                    
                    const uploadResponse = await fetch(`https://${state.serverIP}:5000/api/atleti/${encodeURIComponent(atleta)}/video`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (uploadResponse.ok) {
                        const result = await uploadResponse.json();
                        document.getElementById('btnInviaVideo').textContent = ' Inviato!';
                        setTimeout(() => {
                            document.getElementById('btnInviaVideo').textContent = ' Invia al Server';
                        }, 2000);
                        
                        // Aggiorna lista se siamo nel tab video
                        if (state.archivioAtletaCorrente === atleta) {
                            await archivioCaricaVideo(atleta);
                        }
                    } else {
                        throw new Error('Upload fallito');
                    }
                } catch (e) {
                    alert('Errore invio: ' + e.message);
                    document.getElementById('btnInviaVideo').textContent = ' Invia al Server';
                }
            });
            
            // Inizializza UI server se c' IP salvato
            if (state.serverIP) {
                document.getElementById('serverIP').value = state.serverIP;
            }
            
            // Header menu buttons
            document.getElementById('hdrSettingsBtn').addEventListener('click', () => {
                headerDropdown.classList.remove('open');
                headerHamburger.classList.remove('open');
                openSettingsModal();
            });
            document.getElementById('hdrAthleteBtn').addEventListener('click', () => {
                headerDropdown.classList.remove('open');
                headerHamburger.classList.remove('open');
                openAthletesModal();
            });
            document.getElementById('hdrHelpBtn').addEventListener('click', () => {
                headerDropdown.classList.remove('open');
                headerHamburger.classList.remove('open');
                document.getElementById('manualModal').classList.add('open');
            });
            
            // Settings modal events
            document.getElementById('settingsModalClose').addEventListener('click', closeSettingsModal);
            document.getElementById('settingsSave').addEventListener('click', saveSettings);
            document.getElementById('settingsReset').addEventListener('click', resetSettings);
            
            // Athletes modal - direct access (no PIN)
            document.getElementById('pinModalClose').addEventListener('click', closePinModal);
            document.getElementById('setPinModalClose').addEventListener('click', closeSetPinModal);
            document.getElementById('setPinSave').addEventListener('click', setNewPin);
            
            // Setup PIN inputs
            setupPinInputs(document.querySelectorAll('[data-pin]'), verifyPin);
            setupPinInputs(document.querySelectorAll('[data-newpin]'), (pin) => {
                if (pin.length === 4) setNewPin();
            });
            
            // Athletes modal events
            document.getElementById('athletesModalClose').addEventListener('click', closeAthletesModal);
            document.getElementById('athleteAdd').addEventListener('click', addAthlete);
            document.getElementById('athleteDeselect').addEventListener('click', deselectAthlete);
            
            // Manual modal events
            document.getElementById('manualModalClose').addEventListener('click', () => {
                document.getElementById('manualModal').classList.remove('open');
            });
            
            // Versions modal events
            document.getElementById('versionBtn').addEventListener('click', () => {
                document.getElementById('versionsModal').classList.add('open');
            });
            document.getElementById('versionsModalClose').addEventListener('click', () => {
                document.getElementById('versionsModal').classList.remove('open');
            });
            
            // Close modals on overlay click
            document.querySelectorAll('.modal-overlay').forEach(overlay => {
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        overlay.classList.remove('open');
                    }
                });
            });
        });
        
        // ============ PWA INSTALLATION ============
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            // Show install section
            document.getElementById('installSection').style.display = 'block';
        });
        
        document.getElementById('installBtn')?.addEventListener('click', async () => {
            if (!deferredPrompt) return;
            
            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;
            
            if (outcome === 'accepted') {
                document.getElementById('installSection').style.display = 'none';
            }
            deferredPrompt = null;
        });
        
        window.addEventListener('appinstalled', () => {
            document.getElementById('installSection').style.display = 'none';
            deferredPrompt = null;
            console.log('PWA installed');
        });
        
        // ============ ARCHIVIO SERVER ============
        
        // Variabile per atleta corrente nell'archivio
        state.archivioAtletaCorrente = null;
        
        async function archivioCaricaAtleti() {
            const lista = document.getElementById('listaAtleti');
            lista.innerHTML = '<div class="archivio-empty">Caricamento...</div>';
            
            try {
                const response = await fetch(`https://${state.serverIP}:5000/api/atleti`);
                if (!response.ok) throw new Error('Errore server');
                
                const data = await response.json();
                
                if (data.atleti.length === 0) {
                    lista.innerHTML = '<div class="archivio-empty">Nessun atleta. Aggiungine uno!</div>';
                    return;
                }
                
                lista.innerHTML = data.atleti.map(a => `
                    <div class="archivio-item" data-atleta="${a.nome}">
                        <div class="archivio-item-info">
                            <span class="archivio-item-name"> ${a.nome}</span>
                            <span class="archivio-item-meta">${a.video_count} video</span>
                        </div>
                        <div class="archivio-item-actions">
                            <button class="archivio-item-btn" onclick="event.stopPropagation(); archivioApriVideo('${a.nome}')"> Video</button>
                            <button class="archivio-item-btn danger" onclick="event.stopPropagation(); archivioEliminaAtleta('${a.nome}')"></button>
                        </div>
                    </div>
                `).join('');
                
                // Click su atleta apre video
                lista.querySelectorAll('.archivio-item').forEach(item => {
                    item.addEventListener('click', () => {
                        archivioApriVideo(item.dataset.atleta);
                    });
                });
                
                document.getElementById('serverStatus').innerHTML = '<span style="color: var(--success);"> Connesso</span>';
                
            } catch (e) {
                lista.innerHTML = '<div class="archivio-empty"> Errore connessione server</div>';
                document.getElementById('serverStatus').innerHTML = '<span style="color: var(--danger);"> Non connesso</span>';
            }
        }
        
        async function archivioApriVideo(atleta) {
            state.archivioAtletaCorrente = atleta;
            document.getElementById('nomeAtletaCorrente').textContent = atleta;
            
            // Switch to video tab
            document.querySelectorAll('.archivio-tab').forEach(t => t.classList.remove('active'));
            document.querySelector('.archivio-tab[data-tab="video"]').classList.add('active');
            document.getElementById('tabAtleti').style.display = 'none';
            document.getElementById('tabVideo').style.display = 'block';
            
            await archivioCaricaVideo(atleta);
        }
        
        async function archivioCaricaVideo(atleta) {
            const lista = document.getElementById('listaVideo');
            lista.innerHTML = '<div class="archivio-empty">Caricamento...</div>';
            
            try {
                const response = await fetch(`https://${state.serverIP}:5000/api/atleti/${encodeURIComponent(atleta)}/video`);
                if (!response.ok) throw new Error('Errore server');
                
                const data = await response.json();
                
                if (data.video.length === 0) {
                    lista.innerHTML = '<div class="archivio-empty">Nessun video per questo atleta</div>';
                    return;
                }
                
                lista.innerHTML = data.video.map(v => `
                    <div class="archivio-item" data-video-id="${v.id}">
                        <div class="archivio-item-info">
                            <span class="archivio-item-name"> ${v.id}</span>
                            <span class="archivio-item-meta">
                                ${(v.size / 1024 / 1024).toFixed(1)} MB
                                ${v.has_analisi ? '<span class="archivio-badge">Analizzato</span>' : ''}
                            </span>
                        </div>
                        <div class="archivio-item-actions">
                            <button class="archivio-item-btn" onclick="event.stopPropagation(); archivioScaricaVideo('${atleta}', '${v.id}')"></button>
                            ${!v.has_analisi ? `<button class="archivio-item-btn" onclick="event.stopPropagation(); archivioAnalizza('${atleta}', '${v.id}')"> FpF</button>` : `<button class="archivio-item-btn" onclick="event.stopPropagation(); archivioVediAnalisi('${atleta}', '${v.id}')"></button>`}
                            <button class="archivio-item-btn danger" onclick="event.stopPropagation(); archivioEliminaVideo('${atleta}', '${v.id}')"></button>
                        </div>
                    </div>
                `).join('');
                
            } catch (e) {
                lista.innerHTML = '<div class="archivio-empty"> Errore caricamento video</div>';
            }
        }
        
        async function archivioEliminaAtleta(nome) {
            if (!confirm(`Eliminare l'atleta "${nome}" e tutti i suoi video?`)) return;
            
            try {
                const response = await fetch(`https://${state.serverIP}:5000/api/atleti/${encodeURIComponent(nome)}`, {
                    method: 'DELETE'
                });
                if (response.ok) {
                    await archivioCaricaAtleti();
                }
            } catch (e) {
                alert('Errore eliminazione');
            }
        }
        
        async function archivioEliminaVideo(atleta, videoId) {
            if (!confirm('Eliminare questo video?')) return;
            
            try {
                const response = await fetch(`https://${state.serverIP}:5000/api/atleti/${encodeURIComponent(atleta)}/video/${videoId}`, {
                    method: 'DELETE'
                });
                if (response.ok) {
                    await archivioCaricaVideo(atleta);
                }
            } catch (e) {
                alert('Errore eliminazione');
            }
        }
        
        async function archivioScaricaVideo(atleta, videoId) {
            window.open(`https://${state.serverIP}:5000/api/atleti/${encodeURIComponent(atleta)}/video/${videoId}`, '_blank');
        }
        
        async function archivioAnalizza(atleta, videoId) {
            const btn = event.target;
            btn.textContent = '';
            btn.disabled = true;
            
            try {
                const response = await fetch(`https://${state.serverIP}:5000/api/atleti/${encodeURIComponent(atleta)}/video/${videoId}/analizza`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: state.modelType || 'holistic',
                        quality: 2,
                        fps: 30
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    alert(`Analisi completata!\n${result.frames_analyzed} frame in ${result.analysis_time.toFixed(1)}s`);
                    await archivioCaricaVideo(atleta);
                } else {
                    throw new Error('Errore analisi');
                }
            } catch (e) {
                alert('Errore durante l\'analisi: ' + e.message);
                btn.textContent = ' FpF';
                btn.disabled = false;
            }
        }
        
        async function archivioVediAnalisi(atleta, videoId) {
            try {
                const response = await fetch(`https://${state.serverIP}:5000/api/atleti/${encodeURIComponent(atleta)}/video/${videoId}/analisi`);
                if (!response.ok) throw new Error('Analisi non trovata');
                
                const analisi = await response.json();
                alert(`Analisi: ${analisi.frames_analyzed} frame\nModello: ${analisi.model}\nDurata analisi: ${analisi.analysis_time.toFixed(1)}s`);
                
                // TODO: in futuro potremo visualizzare l'analisi sul video
            } catch (e) {
                alert('Errore caricamento analisi');
            }
        }
        
        // ============ SERVICE WORKER ============
        // Non registrare SW su server locale (porta 5000)
        if ('serviceWorker' in navigator && window.location.port !== '5000') {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then((registration) => {
                        console.log('SW registered:', registration.scope);
                        
                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New version available
                                    if (confirm('Nuova versione disponibile! Aggiornare?')) {
                                        newWorker.postMessage('skipWaiting');
                                        window.location.reload();
                                    }
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.log('SW registration failed:', error);
                    });
            });
        }
        
        // ============ SERVER ARCHIVIO CLUB ============
        const SERVER_URL = 'http://192.168.1.100:8080';
        let serverConnected = false;
        
        // Check server connection
        async function checkServerConnection() {
            try {
                const response = await fetch(`${SERVER_URL}/api/status`, { 
                    method: 'GET',
                    mode: 'cors',
                    timeout: 2000 
                });
                if (response.ok) {
                    serverConnected = true;
                    showArchivioSection();
                    console.log('Server archivio connesso');
                }
            } catch (e) {
                serverConnected = false;
                hideArchivioSection();
                console.log('Server archivio non disponibile');
            }
        }
        
        function showArchivioSection() {
            const section = document.getElementById('archivioSection');
            if (section) section.style.display = 'block';
        }
        
        function hideArchivioSection() {
            const section = document.getElementById('archivioSection');
            if (section) section.style.display = 'none';
        }
        
        // Upload video to server
        async function uploadVideoToServer(blob, athleteName) {
            if (!serverConnected) {
                alert('Server archivio non connesso');
                return false;
            }
            
            const formData = new FormData();
            formData.append('video', blob, `${Date.now()}.webm`);
            formData.append('athlete', athleteName);
            formData.append('timestamp', new Date().toISOString());
            
            try {
                const response = await fetch(`${SERVER_URL}/api/upload`, {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    console.log('Video caricato sul server');
                    return true;
                }
            } catch (e) {
                console.error('Errore upload:', e);
            }
            return false;
        }
        
        // Get videos from server
        async function getAthleteVideos(athleteName) {
            if (!serverConnected) return [];
            
            try {
                const response = await fetch(`${SERVER_URL}/api/videos/${encodeURIComponent(athleteName)}`);
                if (response.ok) {
                    return await response.json();
                }
            } catch (e) {
                console.error('Errore recupero video:', e);
            }
            return [];
        }
        
        // Convert video to MP4
        async function convertToMp4(videoPath) {
            if (!serverConnected) return null;
            
            try {
                const response = await fetch(`${SERVER_URL}/api/convert`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: videoPath })
                });
                
                if (response.ok) {
                    return await response.json();
                }
            } catch (e) {
                console.error('Errore conversione:', e);
            }
            return null;
        }
        
        // Check server connection periodically
        setInterval(checkServerConnection, 10000);
        checkServerConnection();

        // Start the app
        init();
    </script>
</body>
</html>
